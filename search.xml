<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ijm加固反frida分析</title>
      <link href="/2023/03/29/ijm%E5%8A%A0%E5%9B%BA%E5%8F%8Dfrida%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/29/ijm%E5%8A%A0%E5%9B%BA%E5%8F%8Dfrida%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>frida spawn 某个 app 发现进程退了，换了端口和文件名没用，再上 hluda 也没用，嗯。。。看看是什么加固，哦原来是 ijm 企业版，网上翻到两篇不错的分析文章：</p><blockquote><p><a href="https://bbs.kanxue.com/thread-267412.htm">分析一下X加密</a><br><a href="https://www.cnblogs.com/2014asm/p/16120746.html">X加密加固产品原理分析_定制版</a></p></blockquote><p>but 按照这些文章分析的 frida 对抗点应该是防不住 hluda 的，而且听说 ijm 迭代了新版本，那我就来简单分析一下，着重分析它的反调试、模拟器检测、xposed 家族检测和 frida 检测，dex 加载和指令回填就不分析了，免费壳的这部分都大同小异，而且其实 ijm 的加固没有 dex 加载，它只抽了指令。  </p><blockquote><p>前排提示：不想看分析就进入<a href="https://github.com/d0nuts33/bypass-ijm-anti-frida">github仓库</a>直接拿编译好的 frida-server</p></blockquote><span id="more"></span><h1 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h1><hr><p>设备：Pixel<br>系统：Android 8.1<br>架构：armeabi-v7a<br>加固时间：2023年3月中旬</p><blockquote><p>这次把装备升级了，系统版本也升到 8.1，但还是分析 armv7a 架构的so（~~不会 armv8 ~~）。然后因为系统默认使用 armv8 的so，所以在安装apk时使用命令 <code>adb install --abi armeabi-v7a com.xxx.xxx</code> ，注意此时还是Armv8-A架构，只不过是从AArch64切换为AArch32状态来跑so。</p></blockquote><h1 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h1><hr><p>详细分析流程就不说了，有点写流水账的感觉，这里简单说下几个关键函数的逻辑，后面直接总结检测点。</p><ol><li>init_array 前有个 init 函数，它解密了 JNI_OnLoad ，dump 完事。</li><li>init_array 有两个反调试函数，实现三种反调试，分别是 TracerPid 、jdwp 和 wchan</li><li>JNI_OnLoad 注册 native 方法 l，然后这个方法在 attachBaseContext 中被调用，找到这个 l 方法注册的 c 函数，脱壳机检测、isDebuggerConnected 反调试、虚拟机检测、frida 检测以及指令抽取还原逻辑全在里面</li></ol><h1 id="反调试总结"><a href="#反调试总结" class="headerlink" title="反调试总结"></a>反调试总结</h1><hr><ul><li>打开 &#x2F;proc&#x2F;self&#x2F;status ，拿到 <code>TracerPid</code> 的值，不是0就检测出被调试</li><li>从 libart.so 找到 <code>_ZN3art3Dbg8GoActiveEv</code> 和 <code>_ZN3art3Dbg12DdmConnectedEv</code> ，如果是 libdvm.so ，则找到 <code>dvmDbgActive</code> ，hook 它们在入口处调用 <code>exit</code> 的 syscall</li><li>读取 &#x2F;proc&#x2F;self&#x2F;wchan ，返回的字符串不是 <code>sys_epoll_wait</code> 就检测出被调试</li><li>jni 调用 android&#x2F;os&#x2F;Debug 的 <code>isDebuggerConnected</code></li></ul><h1 id="虚拟机检测"><a href="#虚拟机检测" class="headerlink" title="虚拟机检测"></a>虚拟机检测</h1><hr><ul><li><p>调用 access 检查 <code>/dev/qemu_pipe</code> 和 <code>/dev/socket/qemud</code> 文件是否存在，注意这个 access 是系统调用<br><img src="02.png"></p></li><li><p>读取 <code>/proc/tty/drivers</code> ，检查是否有名为 <code>goldfish</code> 的 tty 设备<br><img src="03.png"></p></li><li><p>使用 system_property_get 获取 <code>persist.nox.device</code> 和 <code>persist.nox.baseband</code> 的值，这个是检查夜神模拟器<br><img src="04.png"><br><img src="05.png"></p></li><li><p>读取 <code>init.svc.qemud</code><br><img src="08.png"></p></li><li><p>读取 &#x2F;proc&#x2F;self&#x2F;maps 匹配特征，检测 va ，匹配 <code>io.va.exposed</code> 和 <code>io.virtualapp.sandvxposed</code><br><img src="19.png"></p></li></ul><h1 id="magisk检测"><a href="#magisk检测" class="headerlink" title="magisk检测"></a>magisk检测</h1><hr><ul><li><p>调用 access 检查 <code>/sbin/.magisk</code>、<code>/system/bin/magisk</code> 和 <code>/data/data/com.topjohnwu.magisk</code> 文件是否存在<br><img src="06.png"><br><img src="07.png"></p></li><li><p>读取 &#x2F;proc&#x2F;self&#x2F;maps ，根据内存属性和权限过滤出目标内存段，然后在这些内存段中做逐字节的内存搜索，对于32位匹配 <code>/.magisk</code> 字符串，对于64位匹配 <code>MAGISK_INJ_</code> 字符串<br><img src="16.png"></p></li></ul><h1 id="xposed家族检测"><a href="#xposed家族检测" class="headerlink" title="xposed家族检测"></a>xposed家族检测</h1><hr><ul><li><p>读取 &#x2F;proc&#x2F;self&#x2F;maps ，遍历读出来的每一列，匹配特征 <code>xposed.installer</code> 和 <code>app_process_xposed</code>，注意这个 strstr 是壳自己实现的<br><img src="11.png"></p></li><li><p>读取 &#x2F;proc&#x2F;self&#x2F;maps，匹配特征 <code>libriru_</code>、<code>/data/misc/edxp_</code>、<code>libxposed_art.so</code>、<code>libriruloader.so</code> 和 <code>app_process_zposed</code><br><img src="20.png"><br><img src="12.png"><br><img src="13.png"><br><img src="22.png"><br><img src="36.png"></p></li><li><p>读取 &#x2F;proc&#x2F;self&#x2F;maps ，找到权限为 “r-xp” ，内存大于8192字节的的段，然后对该段做内存搜索匹配字符串 <code>liblspd.so</code> 和 <code>libriru_edxp.so</code><br><img src="14.png"><br><img src="21.png"><br>而且如果内存段映射路径有以下特征就 pass 掉，不检查<br><img src="17.png"></p></li><li><p>调用 system_property_get 读取 <code>ro.dalvik.vm.native.bridge</code> ，riru 开启时会将这个属性设置为注入 so 的路径<br><img src="35.png"></p></li><li><p>调用 access 查找 <code>/system/lib/libriruloader.so</code><br><img src="37.png"></p></li></ul><h1 id="脱壳机检测"><a href="#脱壳机检测" class="headerlink" title="脱壳机检测"></a>脱壳机检测</h1><hr><ul><li><p>&#x2F;proc&#x2F;self&#x2F;maps 匹配特征，查找 <code>top.niunaijun.blackdex</code>、<code>xposed.Fdex2</code>、<code>mapp.rm-</code>、<code>/FunDex/lib/</code>、<code>com.example.FunDex-</code> 和 <code>/data/local/tmp/libFupk3.so</code><br><img src="18.png"><br><img src="25.png"><br><img src="26.png"><br><img src="27.png"></p></li><li><p>反 dexhunter，hook <code>dexReadClassData</code>、<code>DumpClass</code> 等函数<br><img src="38.png"><br>以及反 fupk，也是 hook <code>fupkInvokeMethod</code> 这些特征函数，不细说。<br><img src="39.png"></p></li><li><p>调用 access 检测 <code>/data/dexname</code> 文件，这个是 dexhunter 的特征<br><img src="29.png"></p></li><li><p>调用 FindClass 查找 <code>cn/youlor/Unpacker</code> 类，这是 youpk 的特征<br><img src="30.png"></p></li><li><p>使用 dlsym 查找 libart 的符号，寻找 <code>Unpacker::dumpAllDexes</code> ，<code>Aupk::aupkArtMethod</code> 和 <code>myfartInvoke</code><br><img src="31.png"><br><img src="32.png"><br><img src="34.png"></p></li><li><p>调用 access 检测 &#x2F;data&#x2F;local&#x2F;tmp&#x2F; 下有没有 <code>unpacker.config</code> 和 <code>aupk.config</code> ，前者是 youpk 的配置文件，后者是 aupk 的配置文件，以及检查 fart 工作目录 <code>/data/fart</code><br><img src="33.png"></p></li></ul><h1 id="frida检测"><a href="#frida检测" class="headerlink" title="frida检测"></a>frida检测</h1><hr><ul><li><p>&#x2F;proc&#x2F;self&#x2F;maps 匹配特征，查找 <code>/data/local/tmp/re.frida.server</code> 和 <code>/data/local/</code><br><img src="23.png"><br><img src="24.png"></p></li><li><p>同样是读取 &#x2F;proc&#x2F;self&#x2F;maps 做内存搜索，找到权限为 “r-xp” ，内存大于 8192 字节的的段，这个其实是 frida 注入到目标进程的 frida-agent.so ，它的内存中含有 <code>frida-agent</code> 的字符串特征<br><img src="28.png"></p></li></ul><h1 id="frida检测绕过"><a href="#frida检测绕过" class="headerlink" title="frida检测绕过"></a>frida检测绕过</h1><hr><p>分析这个加固的目的就是绕过它的 frida 检测，圈内流行的方法是 hook pthread_create ，让线程函数不执行，但是有点麻烦，我想修改 frida 源码直接过掉检测，下面就基于 hluda 来修改，版本是 14.2.12。</p><ol><li><p>首先是消除特征 <code>re.frida.server</code> ，找到 <code>frida-core/server/server.vala</code> ，在 main 函数处定义工作文件夹的名字，随便取一个<br><img src="40.png"><br><img src="41.png"></p></li><li><p>然后是工作目录不能再是 <code>/data/local/</code> ，找到 <code>frida-core/src/linux/system-linux.c</code> ，修改 <code>/data/local/tmp</code> 为 <code>/data/tmp</code><br><img src="42.png"></p></li><li><p>接着是内存中不能出现 <code>frida-agent</code> 字符串，hluda 有一个 python 脚本会 patch 掉 frida-agent.so 的线程特征，就在 <code>frida-core/src/anti-anti-frida.py</code> 下，可以在末尾处增加以下代码 patch 掉 frida-agent<br><img src="43.png"><br>同时我发现还有一个线程特征 <code>gdbus</code> 没有 patch 掉，那么顺便增加以下代码<br><img src="44.png"></p></li></ol><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>编译运行，完美绕过 ijm 免费版和企业版的 frida 检测，可以愉快的 hook 了。<del>最后提供编译好的成品（算了，太过分了，自己编译吧）</del></p>]]></content>
      
      
      <categories>
          
          <category> Android加固分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anti-debug </tag>
            
            <tag> anti-frida </tag>
            
            <tag> 模拟器检测 </tag>
            
            <tag> anti-xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zygisk注入原理</title>
      <link href="/2023/02/25/zygisk%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/25/zygisk%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近用上了 lsposed ，发现使用它做开发不用重启手机就能应用新代码，相比 xposed 方便多了，lsposed 又是基于 zygisk 做注入，于是决定来了解一下它的注入原理。阅读下面这几篇文章了解了 magisk 的原理以及 zygisk 的注入原理，知识点又干又硬，根据个人的理解梳理一下，分析的 magisk 版本是 v25.2</p><blockquote><ol><li><a href="https://bbs.kanxue.com/thread-275939.htm">云手机底层技术揭密 : Android系统启动与Magisk原理</a></li><li><a href="https://gist.github.com/5ec1cff/bfe06429f5bf1da262c40d0145e9f190#file-zygisk-md">Zygisk 源码分析</a></li><li><a href="https://bbs.kanxue.com/thread-272295.htm">zygisk原理简单分析和以及zygisk插件开发(1)</a></li><li><a href="https://bbs.kanxue.com/thread-272310.htm">zygisk原理简单分析和以及zygisk插件开发(2)</a></li></ol></blockquote><span id="more"></span><h1 id="Magisk原理"><a href="#Magisk原理" class="headerlink" title="Magisk原理"></a>Magisk原理</h1><hr><p>先从 Magisk 出发，回忆一下 magisk root 的一种方式是在 magisk app 中选择 patch <code>boot.img</code> 文件，结束后拿到 boot.img 重新烧写就完成 root 了。在了解 magisk 对 boot.img 做了什么操作前先回顾 Android 系统的启动流程（截取图片来自<a href="https://bbs.kanxue.com/thread-274572.htm">Lsposed 技术原理探讨 &amp;&amp; 基本安装使用</a>）：</p><p><img src="01.png"></p><p>当系统正常加载时 <code>bootloader</code> 会决定加载 boot.img（解压刷机包能看到这个文件），并执行里面的一个 <code>init</code> 程序，init 程序会完成文件系统的挂载，magisk 正是替换了这个 init 程序，使得 magisk 能在 init 程序中做任何它想做的事情。</p><p>magisk 的 init 程序入口在 <code>native/jni/init/init.cpp</code> 的 <code>main</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (config.skip_initramfs)</span><br><span class="line">        init = new LegacySARInit(argv, &amp;config);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config.force_normal_boot)</span><br><span class="line">        init = new FirstStageInit(argv, &amp;config);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (access(<span class="string">&quot;/sbin/recovery&quot;</span>, F_OK) == <span class="number">0</span> || access(<span class="string">&quot;/system/bin/recovery&quot;</span>, F_OK) == <span class="number">0</span>)</span><br><span class="line">        init = new RecoveryInit(argv, &amp;config);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (check_two_stage())</span><br><span class="line">        init = new FirstStageInit(argv, &amp;config);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        init = new RootFSInit(argv, &amp;config);   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the main routine</span></span><br><span class="line">    init-&gt;start();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据文章可知 magisk 针对 Android 的三种不同的启动方式需要处理四种不同的场景，对应上面代码中 new 出的四个类，我们关注 <code>FirstStageInit</code> 这种场景。</p><p>这种启动方式下，Android 系统会分两个阶段加载文件系统，一阶段属于是二阶段的 loader ，看看原本 init 程序的一阶段代码，在 system&#x2F;core&#x2F;init&#x2F;main.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FirstStageMain()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">&quot;Failed to mount required partitions early ...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* args[] = &#123;path, <span class="string">&quot;selinux_setup&quot;</span>, nullptr&#125;;</span><br><span class="line">    execv(path, const_cast&lt;<span class="type">char</span>**&gt;(args));</span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做了两件事：</p><ul><li>进行一阶段文件目录的挂载，调用 DoFirstStageMount ，挂载 &#x2F;system ，&#x2F;vendor ，&#x2F;product 和 &#x2F;metadata</li><li>调用 execv 执行 <code>/system/bin/init</code>，并传参 “selinux_setup” ，进入二阶段</li></ul><p>回到 magisk 的 init 流程，看到末尾执行 FirstStageInit::start 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span> override &#123;</span><br><span class="line">    prepare();      </span><br><span class="line">    exec_init();    <span class="comment">// 执行原本的init，不是/system/bin/init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepare 函数在 native&#x2F;jni&#x2F;init&#x2F;twostage.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FirstStageInit::prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    xmkdirs(<span class="string">&quot;/data&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    xmount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/data&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="string">&quot;mode=755&quot;</span>);   <span class="comment">// 挂载tmpfs到/data</span></span><br><span class="line">    cp_afc(<span class="string">&quot;/init&quot;</span> <span class="comment">/* magiskinit */</span>, REDIR_PATH);       </span><br><span class="line"></span><br><span class="line">    restore_ramdisk_init();  <span class="comment">// &quot;/.backup&quot;保存原本的init，把它拷贝到&quot;/init&quot;</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> init = mmap_data(<span class="string">&quot;/init&quot;</span>, <span class="literal">true</span>);           <span class="comment">// init文件加载到内存中</span></span><br><span class="line">        <span class="comment">// Redirect original init to magiskinit</span></span><br><span class="line">        init.patch(&#123; <span class="built_in">make_pair</span>(INIT_PATH, REDIR_PATH) &#125;);     <span class="comment">// 在init二进制文件中找到&quot;/system/bin/init&quot;字符串，修改成为&quot;/data/magiskinit&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy files to tmpfs</span></span><br><span class="line">    cp_afc(<span class="string">&quot;.backup&quot;</span>, <span class="string">&quot;/data/.backup&quot;</span>);</span><br><span class="line">    cp_afc(<span class="string">&quot;overlay.d&quot;</span>, <span class="string">&quot;/data/overlay.d&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要做的是替换原 init 文件中的 “&#x2F;system&#x2F;bin&#x2F;init” 字符串为 “&#x2F;data&#x2F;magiskinit” ，即原本的 init 会执行 <code>/system/bin/init</code> ，现在变成执行 <code>/data/magiskinit</code> ，相当于 magisk 劫持了原 init 的二阶段。一阶段流程结束时还得执行原本的 init 程序把 <code>system</code> 文件系统挂载进来。</p><p>在原 init 执行 <code>/data/magiskinit</code> 后二阶段开始，再次来到 <code>native/jni/init/init.cpp</code> 的 <code>main</code> ，根据传入的参数 “selinux_setup” ，构造 SecondStageInit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; argv[<span class="number">1</span>] == <span class="string">&quot;selinux_setup&quot;</span>) &#123;</span><br><span class="line">        init = new SecondStageInit(argv);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着执行 <code>SecondStageInit</code> 的 <code>start</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prepare())</span><br><span class="line">        patch_rw_root();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        patch_ro_root();</span><br><span class="line">    exec_init();            <span class="comment">// 执行&quot;/system/bin/init&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SARBase::patch_ro_root</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    setup_tmp(tmp_dir.data());      <span class="comment">// 挂载tmpfs到/sbin，这里面有用于root的su文件</span></span><br><span class="line">    chdir(tmp_dir.data());          <span class="comment">// 切换到/sbin目录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mount system_root mirror</span></span><br><span class="line">    xmkdir(ROOTMIR, <span class="number">0755</span>);          <span class="comment">// 创建目录&quot;.magisk&quot; &quot;/mirror&quot; &quot;/system_root&quot;</span></span><br><span class="line">    xmount(<span class="string">&quot;/&quot;</span>, ROOTMIR, nullptr, MS_BIND, nullptr);</span><br><span class="line">    mount_list.emplace_back(tmp_dir + <span class="string">&quot;/&quot;</span> ROOTMIR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Patch init.rc</span></span><br><span class="line">    <span class="keyword">if</span> (access(NEW_INITRC, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Android 11&#x27;s new init.rc</span></span><br><span class="line">        xmkdirs(dirname(ROOTOVL NEW_INITRC), <span class="number">0755</span>);</span><br><span class="line">        patch_init_rc(NEW_INITRC, ROOTOVL NEW_INITRC, tmp_dir.data());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        patch_init_rc(<span class="string">&quot;/init.rc&quot;</span>, ROOTOVL <span class="string">&quot;/init.rc&quot;</span>, tmp_dir.data());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract magisk</span></span><br><span class="line">    extract_files(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要来看 patch_init_rc，它会把自己的脚本注入到 <code>init.rc</code>，&#x2F;system&#x2F;bin&#x2F;init 会解析执行 init.rc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">patch_init_rc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src, <span class="type">const</span> <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *tmp_dir)</span> &#123;</span><br><span class="line">    FILE *rc = xfopen(dest, <span class="string">&quot;we&quot;</span>);  <span class="comment">// 打开init.rc</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Inject Magisk rc scripts</span></span><br><span class="line">    <span class="type">char</span> pfd_svc[<span class="number">16</span>], ls_svc[<span class="number">16</span>];</span><br><span class="line">    gen_rand_str(pfd_svc, <span class="keyword">sizeof</span>(pfd_svc));</span><br><span class="line">    gen_rand_str(ls_svc, <span class="keyword">sizeof</span>(ls_svc));</span><br><span class="line">    LOGD(<span class="string">&quot;Inject magisk services: [%s] [%s]\n&quot;</span>, pfd_svc, ls_svc);</span><br><span class="line">    <span class="built_in">fprintf</span>(rc, MAGISK_RC, tmp_dir, pfd_svc, ls_svc);       <span class="comment">// 注入magisk脚本到init.rc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一段脚本如下，这样就导致一个 <code>magisk服务</code> 被拉起，传入 –post-fs-data 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;service %2$s %1$s/magisk --post-fs-data\n&quot;</span><br><span class="line">&quot;    user root\n&quot;</span><br><span class="line">&quot;    seclabel u:r:&quot; SEPOL_PROC_DOMAIN &quot;:s0\n&quot;</span><br><span class="line">&quot;    oneshot\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure><p>magisk 服务代码入口在 native&#x2F;jni&#x2F;core&#x2F;magisk.cpp 的 magisk_main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">magisk_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="string">&quot;-c&quot;</span>sv) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="string">&quot;--post-fs-data&quot;</span>sv) &#123;</span><br><span class="line">        close(connect_daemon(MainRequest::POST_FS_DATA, <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect_daemon 函数与 magiskd 通信，magiskd 的 handle 代码在 native&#x2F;jni&#x2F;core&#x2F;daemon.cpp 的 handle_request_async</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_request_async</span><span class="params">(<span class="type">int</span> client, <span class="type">int</span> code, <span class="type">const</span> sock_cred &amp;cred)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> MainRequest::POST_FS_DATA:</span><br><span class="line">        post_fs_data(client);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入到 native&#x2F;jni&#x2F;core&#x2F;bootstages.cpp 的 post_fs_data ，函数结尾处调用 <code>magic_mount</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">post_fs_data</span><span class="params">(<span class="type">int</span> client)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// We still do magic mount because root itself might need it</span></span><br><span class="line">    magic_mount();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调用 magic_mount 开始进入 <code>zygisk</code> 的流程，总结一下 magisk 的启动流程</p><ol><li>替换 boot.img 的 init 劫持启动的一阶段</li><li>一阶段中 patch 原 init 程序启动 magiskinit 达到劫持二阶段的效果</li><li>二阶段中 patch init.rc，之后 &#x2F;system&#x2F;bin&#x2F;init 会把 magisk 自己的服务跑起来，同时还挂载自己的目录</li></ol><p>简单画个图：</p><p><img src="04.png"></p><h1 id="Zygisk原理"><a href="#Zygisk原理" class="headerlink" title="Zygisk原理"></a>Zygisk原理</h1><hr><p>接着上面来到 magic_mount ，函数底部判断 zygisk 有没有打开来决定是否挂载 zygisk ，重点是 <code>mount_zygisk</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">magic_mount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Mount on top of modules to enable zygisk</span></span><br><span class="line">    <span class="keyword">if</span> (zygisk_enabled) &#123;</span><br><span class="line">        <span class="built_in">string</span> zygisk_bin = MAGISKTMP + <span class="string">&quot;/&quot;</span> ZYGISKBIN;</span><br><span class="line">        mkdir(zygisk_bin.data(), <span class="number">0</span>);</span><br><span class="line">        mount_zygisk(<span class="number">32</span>)</span><br><span class="line">        mount_zygisk(<span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换 <code>app_process</code> 文件为 <code>magisk</code> 文件，根据 Android 启动流程 &#x2F;system&#x2F;bin&#x2F;init 会解析 init.rc 执行 app_process，现在变成执行 magisk 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> app_process_32 = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> app_process_64 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mount_zygisk(bit)                                                            </span></span><br><span class="line"><span class="keyword">if</span> (access(<span class="string">&quot;/system/bin/app_process&quot;</span> <span class="meta">#bit, F_OK) == 0) &#123;                             </span></span><br><span class="line">    app_process_#<span class="meta">#bit = xopen(<span class="string">&quot;/system/bin/app_process&quot;</span> #bit, O_RDONLY | O_CLOEXEC);    <span class="comment">// 全局变量保存app_process文件描述符</span></span></span><br><span class="line">    <span class="built_in">string</span> zbin = zygisk_bin + <span class="string">&quot;/app_process&quot;</span> <span class="meta">#bit;                                  </span></span><br><span class="line">    <span class="built_in">string</span> dbin = zygisk_bin + <span class="string">&quot;/magisk&quot;</span> <span class="meta">#bit;                                       </span></span><br><span class="line">    <span class="built_in">string</span> mbin = MAGISKTMP + <span class="string">&quot;/magisk&quot;</span> <span class="meta">#bit;                                        </span></span><br><span class="line">    <span class="type">int</span> src = xopen(mbin.data(), O_RDONLY | O_CLOEXEC);                              </span><br><span class="line">    <span class="type">int</span> out = xopen(zbin.data(), O_CREAT | O_WRONLY | O_CLOEXEC, <span class="number">0</span>);                 </span><br><span class="line">    xsendfile(out, src, nullptr, INT_MAX);       <span class="comment">// 相当于拷贝了一份magisk，重命名成app_process                                    </span></span><br><span class="line">    close(out);                                                                      </span><br><span class="line">    out = xopen(dbin.data(), O_CREAT | O_WRONLY | O_CLOEXEC, <span class="number">0</span>);                     </span><br><span class="line">    lseek(src, <span class="number">0</span>, SEEK_SET);                                                         </span><br><span class="line">    xsendfile(out, src, nullptr, INT_MAX);                                           </span><br><span class="line">    close(out);                                                                      </span><br><span class="line">    close(src);                                                                      </span><br><span class="line">    clone_attr(<span class="string">&quot;/system/bin/app_process&quot;</span> <span class="meta">#bit, zbin.data());                         </span></span><br><span class="line">    clone_attr(<span class="string">&quot;/system/bin/app_process&quot;</span> <span class="meta">#bit, dbin.data());                         </span></span><br><span class="line">    bind_mount(zbin.data(), <span class="string">&quot;/system/bin/app_process&quot;</span> <span class="meta">#bit);        <span class="comment">// 这里用magisk文件替换/system/bin/app_process                    </span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>magisk 程序入口在 native&#x2F;jni&#x2F;zygisk&#x2F;main.cpp 的 <code>app_process_main</code> ，能够看到 magisk 程序使用 socket 与 magiskd 通信获取原 app_process 的 fd ，再把 <code>/system/bin/bu</code> 添加到 <code>LD_PRELOAD</code> ，这样执行 app_process 后会把这个动态库加载进来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entrypoint for app_process overlay</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">app_process_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> socket = zygisk_request(ZygiskRequest::SETUP); socket &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (read_int(socket) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> app_proc_fd = recv_fd(socket);          <span class="comment">// 接收到原本app_process的fd</span></span><br><span class="line">            <span class="keyword">if</span> (app_proc_fd &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> tmp = read_string(socket);</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">char</span> *ld = getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">                <span class="built_in">string</span> env = ld;</span><br><span class="line">                env += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">                env += HIJACK_BIN;                      <span class="comment">// 在LD_PRELOAD环境变量中添加&quot;/system/bin/bu&quot;</span></span><br><span class="line">                setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, env.data(), <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, HIJACK_BIN, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setenv(INJECT_ENV_1, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            setenv(MAGISKTMP_ENV, tmp.data(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            close(socket);</span><br><span class="line"></span><br><span class="line">            fcntl(app_proc_fd, F_SETFD, FD_CLOEXEC);</span><br><span class="line">            fexecve(app_proc_fd, argv, environ);        <span class="comment">// 执行原本的app_process</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载 <code>/system/bin/bu</code> 的原因是为了劫持 app_process ，在 native&#x2F;jni&#x2F;zygisk&#x2F;entry.cpp 的 setup_files 函数中找到说明，<br>注释中说了劫持 &#x2F;system&#x2F;bin 目录下某些程序，通过代码可以得知 &#x2F;system&#x2F;bin&#x2F;bu 原本是 <code>/sbin/.magisk/zygisk/magisk</code> 文件，而且它是一个动态链接库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_files</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> sock_cred *cred)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// Hijack some binary in /system/bin to host 1st stage</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hbin;</span><br><span class="line">    <span class="built_in">string</span> mbin;</span><br><span class="line">    <span class="type">int</span> app_fd;</span><br><span class="line">    <span class="keyword">if</span> (is_64_bit) &#123;</span><br><span class="line">        hbin = HIJACK_BIN64;</span><br><span class="line">        mbin = MAGISKTMP + <span class="string">&quot;/&quot;</span> ZYGISKBIN <span class="string">&quot;/magisk64&quot;</span>;   <span class="comment">// /sbin/.magisk/zygisk/magisk64</span></span><br><span class="line">        app_fd = app_process_64;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hbin = HIJACK_BIN32;                            <span class="comment">// &quot;/system/bin/bu&quot;</span></span><br><span class="line">        mbin = MAGISKTMP + <span class="string">&quot;/&quot;</span> ZYGISKBIN <span class="string">&quot;/magisk32&quot;</span>;   <span class="comment">// /sbin/.magisk/zygisk/magisk32</span></span><br><span class="line">        app_fd = app_process_32;</span><br><span class="line">    &#125;</span><br><span class="line">    xmount(mbin.data(), hbin, nullptr, MS_BIND, nullptr);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载的动态库声明了构造函数，在 native&#x2F;jni&#x2F;zygisk&#x2F;entry.cpp 的 <code>zygisk_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::constructor]] [[maybe_unused]]</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zygisk_init</span><span class="params">()</span> &#123;</span><br><span class="line">    android_logging();</span><br><span class="line">    <span class="keyword">if</span> (getenv(INJECT_ENV_1)) &#123;</span><br><span class="line">        unsetenv(INJECT_ENV_1);</span><br><span class="line">        first_stage_entry();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(INJECT_ENV_2)) &#123;</span><br><span class="line">        unsetenv(INJECT_ENV_2);</span><br><span class="line">        second_stage_entry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>first_stage_entry</code> 做了环境变量的清理，来看 <code>second_stage_entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">second_stage_entry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    unsetenv(MAGISKTMP_ENV);</span><br><span class="line">    sanitize_environ();</span><br><span class="line">    hook_functions();</span><br><span class="line">    new_daemon_thread(&amp;unload_first_stage, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hook_functions</code> 在 native&#x2F;jni&#x2F;zygisk&#x2F;hook.cpp ， hook 了几个函数，关注 <code>fork</code> 和 <code>jniRegisterNativeMethods</code> ，这两个函数跟注入有关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hook_functions</span><span class="params">()</span> &#123;</span><br><span class="line">    XHOOK_REGISTER(ANDROID_RUNTIME, fork);</span><br><span class="line">    XHOOK_REGISTER(ANDROID_RUNTIME, unshare);</span><br><span class="line">    XHOOK_REGISTER(ANDROID_RUNTIME, jniRegisterNativeMethods);</span><br><span class="line">    XHOOK_REGISTER(ANDROID_RUNTIME, selinux_android_setcontext);</span><br><span class="line">    XHOOK_REGISTER_SYM(ANDROID_RUNTIME, <span class="string">&quot;__android_log_close&quot;</span>, android_log_close);</span><br><span class="line">    hook_refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove unhooked methods</span></span><br><span class="line">    xhook_list-&gt;erase(</span><br><span class="line">            <span class="built_in">std</span>::remove_if(xhook_list-&gt;begin(), xhook_list-&gt;end(),</span><br><span class="line">            [](<span class="keyword">auto</span> &amp;t) &#123; <span class="keyword">return</span> *<span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(t) == nullptr;&#125;),</span><br><span class="line">            xhook_list-&gt;end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_jniRegisterNativeMethods == nullptr) &#123;</span><br><span class="line">        ZLOGD(<span class="string">&quot;jniRegisterNativeMethods not hooked, using fallback\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// android::AndroidRuntime::setArgv0(const char*, bool)</span></span><br><span class="line">        XHOOK_REGISTER_SYM(APP_PROCESS, <span class="string">&quot;_ZN7android14AndroidRuntime8setArgv0EPKcb&quot;</span>, setArgv0);</span><br><span class="line">        hook_refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We still need old_jniRegisterNativeMethods as other code uses it</span></span><br><span class="line">        <span class="comment">// android::AndroidRuntime::registerNativeMethods(_JNIEnv*, const char*, const JNINativeMethod*, int)</span></span><br><span class="line">        constexpr <span class="type">char</span> sig[] = <span class="string">&quot;_ZN7android14AndroidRuntime21registerNativeMethodsEP7_JNIEnvPKcPK15JNINativeMethodi&quot;</span>;</span><br><span class="line">        *(<span class="type">void</span> **) &amp;old_jniRegisterNativeMethods = dlsym(RTLD_DEFAULT, sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂钩的 <code>jniRegisterNativeMethods</code> 又 hook 了 <code>nativeForkAndSpecialize</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DCL_HOOK_FUNC(<span class="type">int</span>, jniRegisterNativeMethods,</span><br><span class="line">        JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *className, <span class="type">const</span> JNINativeMethod *methods, <span class="type">int</span> numMethods) &#123;</span><br><span class="line">    ZLOGV(<span class="string">&quot;jniRegisterNativeMethods [%s]\n&quot;</span>, className);</span><br><span class="line">    <span class="keyword">auto</span> newMethods = hookAndSaveJNIMethods(className, methods, numMethods);</span><br><span class="line">    <span class="keyword">return</span> old_jniRegisterNativeMethods(env, className, newMethods.get() ?: methods, numMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;JNINativeMethod[]&gt; </span><br><span class="line"><span class="title function_">hookAndSaveJNIMethods</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *className, <span class="type">const</span> JNINativeMethod *methods, <span class="type">int</span> numMethods)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numMethods; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hook_cnt &amp;&amp; clz_id == <span class="number">0</span>) &#123;</span><br><span class="line">            HOOK_JNI(nativeForkAndSpecialize)</span><br><span class="line">            HOOK_JNI(nativeSpecializeAppProcess)</span><br><span class="line">            HOOK_JNI(nativeForkSystemServer)</span><br><span class="line">        &#125;</span><br><span class="line">        class_map[methods[i].name][methods[i].signature] = methods[i].fnPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Android 应用启动流程，zygote 在接收到启动新进程的 socket 通信请求时就会调用 <code>nativeForkAndSpecialize</code> 进而调用 <code>fork</code> 创建新的进程，而被hook后会先调用<code>nativeForkAndSpecialize_pre</code>，这个函数做了一次 fork ，原本的 nativeForkAndSpecialize 也会调用 fork ，调用两次 fork 不正常，回想起 fork 也被 hook 了，看看 hook 后的 fork 做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HookContext::fork_pre</span><span class="params">()</span> &#123;</span><br><span class="line">    g_ctx = this;</span><br><span class="line">    sigmask(SIG_BLOCK, SIGCHLD);</span><br><span class="line">    pid = old_fork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HookContext::nativeForkAndSpecialize_pre</span><span class="params">()</span> &#123;</span><br><span class="line">    fork_pre();     <span class="comment">// 这里先做了fork，但实际调用到new_fork，里面判断gtx-&gt;pid是否大于0，若是直接返回pid</span></span><br><span class="line">    state[FORK_AND_SPECIALIZE] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        nativeSpecializeAppProcess_pre();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook 后的 fork 会先判断 <code>g_ctx-&gt;pid</code> 的值是否为 0 ，若为 0 表示它没做过 fork ，进而调用原本的 fork 函数，若不为 0 就直接返回 pid ，这个是子进程的 pid 值，说明 nativeForkAndSpecialize 的第二次 fork 不会调用真正的 fork 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DCL_HOOK_FUNC(<span class="type">int</span>, fork) &#123;</span><br><span class="line">    <span class="keyword">return</span> (g_ctx &amp;&amp; g_ctx-&gt;pid &gt;= <span class="number">0</span>) ? g_ctx-&gt;pid : old_fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前做 fork 是为什么呢？回到 nativeForkAndSpecialize_pre ，它调用的 nativeSpecializeAppProcess_pre 会做 zygisk 模块的加载，也就是说 zygisk 为了让 fork 后的进程加载模块，就得提前 fork ，这样还在它自己的代码空间，它可以根据 denylist 决定是否加载模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HookContext::nativeSpecializeAppProcess_pre</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; module_fds;</span><br><span class="line">    <span class="type">int</span> fd = remote_get_info(args-&gt;uid, process, &amp;flags, module_fds);</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; UNMOUNT_MASK) == UNMOUNT_MASK) &#123;</span><br><span class="line">        ZLOGI(<span class="string">&quot;[%s] is on the denylist\n&quot;</span>, process);</span><br><span class="line">        state[DO_UNMOUNT] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        run_modules_pre(module_fds);        <span class="comment">// 模块加载</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zygisk 这种在 fork 后加载模块的方式使得它可以在不重启的情况下更新 lsposed 代码，对比 xposed 的方式，xposed 在的 XposedInit 里就把模块加载进来，再进行正常的 ZygoteInit 启动流程，使得 zygote 之后 fork 的每一个进程都带有模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="type">static</span> <span class="type">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            XposedInit.loadModules();  <span class="comment">// 加载 Xposed 模块</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Not initializing Xposed because of previous errors&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Errors during Xposed initialization&quot;</span>, t);</span><br><span class="line">        disableHooks = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Call the original startup code</span></span><br><span class="line">    <span class="keyword">if</span> (isZygote) &#123;</span><br><span class="line">        ZygoteInit.main(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RuntimeInit.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>zygisk 利用预先 fork 的方式把模块加载到进程中，相比 xposed 更巧妙。文章只是分析了 lsposed 的注入原理，它本身还有很多值得研究的地方，后面学习 magisk 隐藏可能还会再深入分析，感谢项目作者提供这么好用的开源工具。</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> magisk </tag>
            
            <tag> lsposed </tag>
            
            <tag> zygisk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某聊天app获取用户头像url分析</title>
      <link href="/2023/02/25/%E6%9F%90%E8%81%8A%E5%A4%A9app%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%A4%B4%E5%83%8Furl%E5%88%86%E6%9E%90/"/>
      <url>/2023/02/25/%E6%9F%90%E8%81%8A%E5%A4%A9app%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%A4%B4%E5%83%8Furl%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>分析一个海外 app，目标是找到 app 发送获取用户头像请求接口并用 frida 实现主动调用</p><span id="more"></span><h1 id="抓包初步分析"><a href="#抓包初步分析" class="headerlink" title="抓包初步分析"></a>抓包初步分析</h1><hr><p>因为不知道用户头像关键字，所以没法在 jadx 中直接搜索定位关键位置，考虑抓包定位。<br>搜索好友时能看到用户的头像，这里肯定有图片请求，图片 url 一般都是 http 请求，直接上中间人抓包工具</p><p><img src="02.png"></p><p>看起来 url 有点复杂，应该不需要自己构造，可能是前面某个请求的 response 中带有这条 url ，在抓到的包中翻找也只找到 <code>toUid</code> 接口，作用是通过用户名获取 uid 值，且该包应答中并没有头像 url  </p><p><img src="03.png"></p><p><img src="04.png"></p><h1 id="找关键方法并编写主动调用代码"><a href="#找关键方法并编写主动调用代码" class="headerlink" title="找关键方法并编写主动调用代码"></a>找关键方法并编写主动调用代码</h1><hr><p>先在 jadx 中搜索 “toUid” 看看</p><p><img src="05.png"></p><p>转到引用常量值的地方，找到 <code>queryUid</code> 方法，所属类是 <code>ApiClientHelper</code> ，上下翻没找到 query 头像相关逻辑</p><p><img src="06.png"></p><p>因为 app 用了 okhttp 发送 http 请求，于是我尝试 hook <code>okhttp3.Request.Builder.url</code> ，想通过函数栈回溯头像请求的产生位置，然而 app 的 http 请求是异步，即请求的产生与发送在两个不同的线程，回溯发送线程函数栈自然是找不到请求的构造点。<br>换一个思路，请求返回的 json 数据肯定要解析，拿到里面的uid然后保存到某个表示用户的类实例中，hook <code>org.json.JSONObject.$init</code> 和 <code>com.google.gson.Gson.fromJson</code> ，在传给 <code>Gson.fromJson</code> 的参数上发现了回应数据</p><p><img src="07.png"></p><p>接着打印它的函数栈，其中的 <code>queryMtcUserProp</code> 很让人在意，意思是查询用户属性，头像也属于用户属性</p><p><img src="08.png"></p><p>看看 MtcUserManager 的 queryMtcUserProp 方法</p><p><img src="09.png"></p><p>hook 打印它的参数和函数栈，可以看到参数就是 uid ，请求是在 RxSearch 的 <code>searchByJusTalkId</code> 方法发起的</p><p><img src="10.png"></p><p>searchByJusTalkId 第一个参数是搜索栏输入的用户名，该方法用了 RxJava ，分析起来挺痛苦的，我在图中把要点画了出来。首先经过本地查找，找不到就调用 <code>lambda$searchByJusTalkId$7</code> 发请求</p><p><img src="11.png"></p><p>lambda$searchByJusTalkId$7 调用关键方法 <code>RxUidManager.queryOneImpl</code></p><p><img src="12.png"></p><p>hook 它得知参数是 toUid 接口的 uriList 字段，返回值是查询结果，只不过是 <code>Observable&lt;string&gt;</code> 类型，从里面可以取出 uid 字符串</p><p><img src="13.png"></p><p><img src="14.png"></p><p>因为请求头像需要 uid ，所以这里要 hook <code>queryOneImpl</code> ，然后解析返回值。解析 Observable 需要创建观察者 Observer ，然后实现它的 onNext ，方法传进来的参数即是我想要的 uid 字符串，用 frida 写个主动调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">internalQueryUid</span>(<span class="params">userName</span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> uri = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.juphoon.justalk.utils.MtcExtUtils&quot;</span>).<span class="title class_">Mtc</span>_UserFormUriX(<span class="string">&quot;username&quot;</span>, userName);   </span><br><span class="line">        <span class="keyword">var</span> observer = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;io.reactivex.Observer&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> observerImpl = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;com.juphoon.justalk.rx.ObserverImpl&quot;</span>,</span><br><span class="line">            <span class="attr">implements</span>: [observer],</span><br><span class="line">            <span class="attr">methods</span>: &#123;</span><br><span class="line">                <span class="title function_">onSubscribe</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">onNext</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;uid: &#x27;</span> + arg);     <span class="comment">// 这里拿到uid</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">onError</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">onComplete</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">RxUidManager</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.juphoon.justalk.rx.RxUidManager&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> observable = <span class="title class_">RxUidManager</span>.<span class="title function_">queryOneImpl</span>(uri);  <span class="comment">// 主动调用</span></span><br><span class="line"></span><br><span class="line">        observable.<span class="title function_">subscribe</span>(observerImpl.$new());  <span class="comment">// 订阅被观察者实例</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queryOneImpl</code> 请求完后继续往下进入 <code>lambda$searchByJusTalkId$5</code></p><p><img src="15.png"></p><p>找到第二个关键方法 <code>queryMtcUserProp</code></p><p><img src="16.png"></p><p>进入里面看到使用 json 保存要查询的属性值，然后继续跟入</p><p><img src="17.png"></p><p>在这调用的 <code>Mtc_BuddyQueryUserId</code> 方法第一个参数是回调函数，用于接收回应数据，第二个参数是 uid ，第三个参数是前面的 json 转成的字符串</p><p><img src="18.png"></p><p>最后调用 MtcBuddy 的 jni 函数</p><p><img src="19.png"></p><p>同时还发现查询用户 id 也有相应的 jni 函数，就不需要使用 RxJava 订阅的方式获取返回数据了</p><p><img src="20.png"></p><p>总结一下：</p><ol><li>调用 <code>MtcBuddy</code> 的 <code>Mtc_BuddyQueryUserId</code> 获取用户 id ，第一个参数是回调函数对应的序号，第二个参数是用户名组成的 url ，这一步获取 uid 值</li><li>调用 <code>MtcBuddy</code> 的 <code>Mtc_BuddyQueryProperty</code> 获取头像 url ，第一个是回调函数对应的序号，第二个参数是 uid 字符串</li></ol><p>再看看怎么创建用于接收应答数据的回调</p><p><img src="21.png"></p><p>Callback 是 MtcNotify 的内部接口，实现它的 mtcNotified 即可，返回数据在第三个参数上，第二个参数是回调序号，之后调用 MtcNotify 的 <code>addCallback</code> 注册回调，这个方法就会返回回调函数对应的序号</p><p>同样用 frida 编写主动调用代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Callback</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.justalk.ui.MtcNotify$Callback&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">CallbackImpl</span> = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">        name : <span class="string">&quot;com.justalk.ui.MtcNotify.CallbackImpl&quot;</span>,</span><br><span class="line">        implements : [<span class="title class_">Callback</span>],</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            mtcNotified (name, cookie, info) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cookie == callbackCookie) &#123;</span><br><span class="line">                    userInfo = info;</span><br><span class="line">                    <span class="comment">//console.log(userInfo);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">MtcNotify</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.justalk.ui.MtcNotify&quot;</span>);</span><br><span class="line">    callbackCookie = <span class="title class_">MtcNotify</span>.<span class="title function_">addCallback</span>(<span class="title class_">CallbackImpl</span>.$new());    <span class="comment">// 拿到回调序号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户属性值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">internalQueryUserInfo</span>(<span class="params">uid</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> jsonArray = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;org.json.JSONArray&quot;</span>).$new();</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;Basic.NickName&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;Basic.Birthday&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;Basic.Gender&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;thumbnailUrl&quot;</span>);      <span class="comment">// 这个是头像url</span></span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;hdAvatarUrl&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;Public.Version&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;loginCountry&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;justalkId&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;premiumDue&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;plusDue&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;educationDue&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;suspect&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;SysSetting.BanEndTime&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">    jsonArray.<span class="title function_">put</span>(<span class="string">&quot;parentPhone&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">MtcBuddy</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.justalk.cloud.lemon.MtcBuddy&quot;</span>);</span><br><span class="line">    <span class="title class_">MtcBuddy</span>.<span class="title class_">Mtc</span>_BuddyQueryProperty(callbackCookie, uid, jsonArray.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，输入用户名 “ghost”<br><img src="23.png"></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>整个过程最耗时间的是找到调用点，之后 frida 脚本就好写了。后续可以把 frida 移植到 xposed 上，搭配模拟器跟 sekiro 的组合就可以做一个爬虫服务器了。</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> 协议分析 </tag>
            
            <tag> frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非平坦化混淆总结</title>
      <link href="/2023/02/21/%E9%9D%9E%E5%B9%B3%E5%9D%A6%E5%8C%96%E6%B7%B7%E6%B7%86%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/21/%E9%9D%9E%E5%B9%B3%E5%9D%A6%E5%8C%96%E6%B7%B7%E6%B7%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>整理那些见过的非平坦化、非 bcf 混淆，以后见到新的再添加进来。</p><span id="more"></span><h1 id="函数名称混淆"><a href="#函数名称混淆" class="headerlink" title="函数名称混淆"></a>函数名称混淆</h1><hr><p>利用 deinfe 宏对函数名做重命名，编译时编译器会用后面那串玩意替代函数名</p><p><img src="01.jpg"></p><p>效果如下，其实意义不大，还是能够通过分析函数逻辑知晓其功能</p><p><img src="02.jpg"></p><h1 id="修改返回地址"><a href="#修改返回地址" class="headerlink" title="修改返回地址"></a>修改返回地址</h1><hr><p>计算出一个值放到 R0 寄存器，倒数第二句指令用 R0 覆盖掉栈上的 LR ，最后一句指令 <code>pop pc</code> 跳转过去，这就是美团 libmtguard 中的混淆</p><p><img src="03.jpg"></p><p>修改执行流还得搭配垃圾数据或指令才能扰乱 ida 的分析，像下图这种，在混淆数据前调用函数，函数中修改返回值跳过混淆数据。</p><p><img src="11.jpg"></p><h1 id="直接修改PC"><a href="#直接修改PC" class="headerlink" title="直接修改PC"></a>直接修改PC</h1><hr><p>同样是修改执行流，往 PC 寄存器 <code>mov</code> 一个地址</p><p><img src="10.jpg"></p><h1 id="插入破坏栈平衡的指令"><a href="#插入破坏栈平衡的指令" class="headerlink" title="插入破坏栈平衡的指令"></a>插入破坏栈平衡的指令</h1><hr><p>下图中的指令 <code>ADD SP,SP, #0x40</code> 修改了栈指针 SP ，导致栈不平衡</p><p><img src="04.jpg"></p><p>F5 后能看到 ida 提示了 “positive sp value has been detected, the output may be wrong!”</p><p><img src="05.jpg"></p><p>解决办法参考：<a href="https://bbs.pediy.com/thread-140002.htm%E5%92%8Chttps://bbs.pediy.com/thread-158896.htm">https://bbs.pediy.com/thread-140002.htm和https://bbs.pediy.com/thread-158896.htm</a></p><p>首先勾选 <code>Stack pointer</code></p><p><img src="06.jpg"></p><p>然后是检查整个函数有哪些指令操作了 SP ，这些指令后的指令栈指针值是负数的，找出来然后 nop 掉</p><p><img src="07.jpg"></p><h1 id="栈展开函数stack-check-fail识别失败"><a href="#栈展开函数stack-check-fail识别失败" class="headerlink" title="栈展开函数stack_check_fail识别失败"></a>栈展开函数stack_check_fail识别失败</h1><hr><p>这种会导致 make function 失败，如下图，loc_2404 就是 stack_check_fail 函数，它的上面的 pop 指令就是函数末尾处，再往上 0x23FE 处会跳过函数末尾到达 loc_2404 ，这其实是检查有没有栈溢出，所以跳转 stack_check_fail 函数，这个函数应该会使程序退出</p><p><img src="08.jpg"></p><p>进入 sub_47FC 看看，编辑该函数可以看到 ida 识别它是返回的，那就不对了，把 <code>Does not return</code> 勾选了，然后在函数开头按 <code>p</code> 键创建函数</p><p><img src="09.jpg"></p><h1 id="无条件跳转JUMPOUT"><a href="#无条件跳转JUMPOUT" class="headerlink" title="无条件跳转JUMPOUT"></a>无条件跳转JUMPOUT</h1><hr><p>利用 ida 无法计算动态值，构造地址无条件跳转，使得 ida 识别的函数提前结束，如下图所示，实际上 BX R5 只是跳到下面不远处，而中间塞了一些垃圾数据。</p><p><img src="12.jpg"></p><p>对这种只能根据指令特征写脚本 patch</p>]]></content>
      
      
      <categories>
          
          <category> Android加固分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混淆 </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节系app抓包</title>
      <link href="/2023/02/19/%E5%AD%97%E8%8A%82%E7%B3%BBapp%E6%8A%93%E5%8C%85/"/>
      <url>/2023/02/19/%E5%AD%97%E8%8A%82%E7%B3%BBapp%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>抓今日头条包（版本9.1.6），发现各种抓不到，最后找到个脚本 hook 它在 java 层的收发包函数，也算是一种抓包方式。</p><blockquote><p>更新：经过测试，透明代理方式也可以抓到包 -&gt; <a href="https://blog.seeflower.dev/archives/207/">安卓上基于透明代理对特定APP抓包</a></p></blockquote><span id="more"></span><h1 id="找到hook点"><a href="#找到hook点" class="headerlink" title="找到hook点"></a>找到hook点</h1><hr><p>r0capture 抓不到明文包，中间人抓包则会导致 app 请求不了网络数据，应该是做了证书绑定，试了几个 bypass ssl pinning 脚本也不管用，反编译发现它不是一般的对 okhttp 的混淆，而是自己封装实现了 okhttp ，用 adb logact 看到如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">02-18 20:36:09.758 30350 31893 W System.err: com.bytedance.frameworks.baselib.network.http.cronet.impl.CronetIOException: :0|Exception in CronetUrlRequest: net::ERR_TTNET_APP_TIMED_OUT, ip=:0, details=&#123;...&#125;, attempts= , dns=2003, connect=-1, ssl=-1, send=-1, proxy=-1, wait=-1, receive=-1, total=-1, reused=0, cached=0, response_content_len=0, total_bytes=0, is_proxy=0, QuicStreamError=0, QuicCloseS</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at X.796.execute(SourceFile:524816)</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at com.bytedance.retrofit2.CallServerInterceptor.executeCall(SourceFile:33816611)</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at com.bytedance.retrofit2.CallServerInterceptor.intercept(SourceFile:17236173)</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at com.bytedance.retrofit2.intercept.RealInterceptorChain.proceed(SourceFile:17170567)</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at com.bytedance.frameworks.baselib.network.http.retrofit.RequestVertifyInterceptor.intercept(SourceFile:17104962)</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at com.bytedance.retrofit2.intercept.RealInterceptorChain.proceed(SourceFile:17170567)</span><br><span class="line">02-08 18:04:01.543  3477  4560 W System.err:    at X.0fr.intercept(SourceFile:17104974)</span><br></pre></td></tr></table></figure><p>看看类 <code>X.796</code> 的 <code>execute</code> 方法，可以确定在这里发送请求并且拿到数据，那么 hook 这里同时打印 request 和 response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.request.getUrl();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.f82341g) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> getCode(SsCronetHttpClient.processExecute(<span class="built_in">this</span>.request, <span class="built_in">this</span>.httpURLConnection));   <span class="comment">// 这里发送请求</span></span><br><span class="line">                <span class="built_in">this</span>.baseHttpRequestInfo.responseBack = System.currentTimeMillis();</span><br><span class="line">                <span class="built_in">this</span>.baseHttpRequestInfo.recycleCount = -<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">this</span>.f82339e = SsCronetHttpClient.processAfterExecute(<span class="built_in">this</span>.httpURLConnection, <span class="built_in">this</span>.baseHttpRequestInfo, code);</span><br><span class="line">                <span class="built_in">this</span>.f82345k = SsCronetHttpClient.getHeaderValueIgnoreCase(<span class="built_in">this</span>.httpURLConnection, <span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.request.isResponseStreaming()) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">maxLength2</span> <span class="operator">=</span> <span class="built_in">this</span>.request.getMaxLength();</span><br><span class="line">                    <span class="built_in">this</span>.baseHttpRequestInfo.contentType = SsCronetHttpClient.getContentBaseType(<span class="built_in">this</span>.f82345k);</span><br><span class="line">                    typedByteArray = <span class="keyword">new</span> <span class="title class_">TypedByteArray</span>(<span class="built_in">this</span>.f82345k, SsCronetHttpClient.processResponse(url, maxLength2, <span class="built_in">this</span>.httpURLConnection, <span class="built_in">this</span>.f82338d, <span class="built_in">this</span>.baseHttpRequestInfo, <span class="built_in">this</span>.f82339e, code, <span class="built_in">this</span>.f82343i), <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里拿返回数据</span></span><br><span class="line">                <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Response</span>(url, code, <span class="built_in">this</span>.httpURLConnection.getResponseMessage(), SsCronetHttpClient.createHeaders(<span class="built_in">this</span>.httpURLConnection, f82333l), typedByteArray);</span><br><span class="line">                response.setExtraInfo(<span class="built_in">this</span>.baseHttpRequestInfo);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">               ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;request canceled&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="脚本hook"><a href="#脚本hook" class="headerlink" title="脚本hook"></a>脚本hook</h1><hr><p>刚好找到一位大佬的代码：<a href="https://github.com/siyujie/OkHttpLogger-Frida/blob/master/aweme_httpcat.js">aweme_httpcat.js</a><br>拿来改成对 <code>X.796.execute</code> 的 hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getObjClassName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> jclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> jobj = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jclazz.<span class="property">getName</span>.<span class="title function_">call</span>(jobj.<span class="property">getClass</span>.<span class="title function_">call</span>(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileFilterArray = [<span class="string">&quot;.webp&quot;</span>,<span class="string">&quot;.png&quot;</span>,<span class="string">&quot;.jpg&quot;</span>,<span class="string">&quot;.jpeg&quot;</span>,<span class="string">&quot;.image&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isBlackListUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fileFilterArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(fileFilterArray[i]) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(url + <span class="string">&quot; ?? &quot;</span> + fileFilterArray[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">splitLine</span>(<span class="params">string, tag</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lineLength = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">var</span> newSB = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringBuilder&quot;</span>).$new()</span><br><span class="line">    <span class="keyword">var</span> newString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(string)</span><br><span class="line">    <span class="keyword">var</span> lineNum = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(newString.<span class="title function_">length</span>() / lineLength)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lineNum; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> start = i * lineLength;</span><br><span class="line">        <span class="keyword">var</span> end = (i + <span class="number">1</span>) * lineLength</span><br><span class="line">        newSB.<span class="title function_">append</span>(tag)</span><br><span class="line">        <span class="keyword">if</span> (end &gt; newString.<span class="title function_">length</span>()) &#123;</span><br><span class="line">            newSB.<span class="title function_">append</span>(newString.<span class="title function_">substring</span>(start, newString.<span class="title function_">length</span>()))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newSB.<span class="title function_">append</span>(newString.<span class="title function_">substring</span>(start, end))</span><br><span class="line">        &#125;</span><br><span class="line">        newSB.<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newSB.<span class="title function_">deleteCharAt</span>(newSB.<span class="title function_">length</span>() - <span class="number">1</span>).<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">openClassFile</span>(<span class="string">&quot;/data/local/tmp/dexfile/okhttpfind.dex&quot;</span>).<span class="title function_">load</span>();</span><br><span class="line">        <span class="keyword">var</span> class_string = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_integer = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_stringBuffer = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringBuffer&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_jsonObject = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;org.json.JSONObject&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_JavaLinkedTreeMap = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.singleman.gson.internal.LinkedTreeMap&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_byteString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.singleman.okio.ByteString&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_byteArrayOutputStream = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.ByteArrayOutputStream&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> class_javaMap = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Map&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> gson = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.singleman.gson.Gson&quot;</span>).$new();</span><br><span class="line">        <span class="keyword">var</span> <span class="variable constant_">X796</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;X.796&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> fields = <span class="variable constant_">X796</span>.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line">        <span class="keyword">var</span> requestField = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> field <span class="keyword">of</span> fields) &#123;</span><br><span class="line">            field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (class_string.$new(<span class="string">&quot;f&quot;</span>).<span class="title function_">equals</span>(field.<span class="title function_">getName</span>())) &#123;</span><br><span class="line">                requestField = field;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable constant_">X796</span>[<span class="string">&quot;execute&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="variable language_">this</span>.<span class="title function_">execute</span>();</span><br><span class="line">            <span class="keyword">if</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;can not find response field&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> request = <span class="title class_">Java</span>.<span class="title function_">cast</span>(requestField.<span class="title function_">get</span>(<span class="variable language_">this</span>), <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.bytedance.retrofit2.client.Request&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (request == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;can not find request field&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> logString = class_stringBuffer.$new();</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="comment">// url</span></span><br><span class="line">            <span class="keyword">var</span> url = request.<span class="title function_">getUrl</span>();</span><br><span class="line">            <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">                url = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;| URL&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="title function_">splitLine</span>(url, <span class="string">&quot;|    &quot;</span>)).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isBlackListUrl</span>(url)) &#123;</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(logString);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// extra info</span></span><br><span class="line">            <span class="keyword">var</span> extraInfo = response.<span class="title function_">getExtraInfo</span>();</span><br><span class="line">            <span class="keyword">if</span> (extraInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> requestLogString = extraInfo.<span class="title function_">getClass</span>().<span class="title function_">getField</span>(<span class="string">&quot;requestLog&quot;</span>).<span class="title function_">get</span>(extraInfo);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != requestLogString) &#123;</span><br><span class="line">                    <span class="keyword">var</span> jsonObject = class_jsonObject.$new(requestLogString);</span><br><span class="line">                    <span class="keyword">var</span> baseJsonObj = jsonObject.<span class="title function_">getJSONObject</span>(<span class="string">&quot;base&quot;</span>);</span><br><span class="line">                    <span class="keyword">var</span> httpMethod = baseJsonObj.<span class="title function_">getString</span>(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">                    <span class="keyword">var</span> originUrl = baseJsonObj.<span class="title function_">getString</span>(<span class="string">&quot;origin_url&quot;</span>);</span><br><span class="line">                    logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;Method : &quot;</span> + httpMethod + <span class="string">&quot;  originUrl : &quot;</span> + originUrl).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Request Headers</span></span><br><span class="line">                <span class="keyword">var</span> requestHeadersString = extraInfo.<span class="title function_">getClass</span>().<span class="title function_">getField</span>(<span class="string">&quot;requestHeaders&quot;</span>).<span class="title function_">get</span>(extraInfo);</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;Request Headers&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> requestHeaderMapObj = gson.<span class="title function_">fromJson</span>(requestHeadersString, class_javaMap.<span class="property">class</span>);</span><br><span class="line">                <span class="keyword">var</span> requestHeaderMap = <span class="title class_">Java</span>.<span class="title function_">cast</span>(requestHeaderMapObj, class_JavaLinkedTreeMap);</span><br><span class="line">                <span class="keyword">var</span> keyArray = requestHeaderMap.<span class="title function_">keySet</span>().<span class="title function_">toArray</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keyArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> key = keyArray[i];</span><br><span class="line">                    <span class="keyword">var</span> value = requestHeaderMap.<span class="title function_">get</span>(key);</span><br><span class="line">                    logString.<span class="title function_">append</span>(<span class="string">&quot;|    &quot;</span> + key + <span class="string">&quot;:&quot;</span> + value).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Request Bodys</span></span><br><span class="line">            <span class="keyword">var</span> requestBody = request.<span class="title function_">getBody</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != requestBody) &#123;</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;Request Body&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> byteArrayOutputStream = class_byteArrayOutputStream.$new();</span><br><span class="line">                requestBody[<span class="string">&quot;writeTo&quot;</span>](byteArrayOutputStream);</span><br><span class="line">                <span class="keyword">var</span> bodyString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> bodyByteString = class_byteString.<span class="title function_">of</span>(byteArrayOutputStream.<span class="title function_">toByteArray</span>());</span><br><span class="line">                    bodyString = bodyByteString.<span class="title function_">utf8</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    bodyString = <span class="string">&quot;Base64[&quot;</span> + bodyByteString.<span class="title function_">base64</span>() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="title function_">splitLine</span>(bodyString, <span class="string">&quot;|    &quot;</span>)).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Response Code</span></span><br><span class="line">            <span class="keyword">var</span> code = response.<span class="title function_">getStatus</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//var reason = response.getReason()</span></span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;code : &quot;</span> + code).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Response Headers</span></span><br><span class="line">            <span class="keyword">if</span> (extraInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> responseHeadersString = extraInfo.<span class="title function_">getClass</span>().<span class="title function_">getField</span>(<span class="string">&quot;responseHeaders&quot;</span>).<span class="title function_">get</span>(extraInfo);</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;Response Headers&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> responseHeaderMapObj = gson.<span class="title function_">fromJson</span>(responseHeadersString, class_javaMap.<span class="property">class</span>);</span><br><span class="line">                <span class="keyword">var</span> responseHeaderMap = <span class="title class_">Java</span>.<span class="title function_">cast</span>(responseHeaderMapObj, class_JavaLinkedTreeMap);</span><br><span class="line">                <span class="keyword">var</span> keyArray = responseHeaderMap.<span class="title function_">keySet</span>().<span class="title function_">toArray</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keyArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> key = keyArray[i];</span><br><span class="line">                    <span class="keyword">var</span> value = responseHeaderMap.<span class="title function_">get</span>(key);</span><br><span class="line">                    logString.<span class="title function_">append</span>(<span class="string">&quot;|    &quot;</span> + key + <span class="string">&quot;:&quot;</span> + value).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Response Body</span></span><br><span class="line">            <span class="keyword">var</span> responseBody = response[<span class="string">&quot;getBody&quot;</span>]();</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;mimeType : &quot;</span> + responseBody[<span class="string">&quot;mimeType&quot;</span>]()).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            logString.<span class="title function_">append</span>(<span class="string">&quot;| &quot;</span> + <span class="string">&quot;Body&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> inputSteam = responseBody.<span class="title function_">in</span>();</span><br><span class="line">            <span class="keyword">var</span> length = responseBody.<span class="title function_">length</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> lengthInt = class_integer.<span class="title function_">valueOf</span>(class_string.<span class="title function_">valueOf</span>(length));</span><br><span class="line">            <span class="keyword">if</span> (responseBody.<span class="property">$className</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;TypedByteArray&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> byteString = class_byteString.<span class="title function_">read</span>(inputSteam, lengthInt[<span class="string">&quot;intValue&quot;</span>]());</span><br><span class="line">                <span class="keyword">var</span> bodyString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bodyString = byteString.<span class="title function_">utf8</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    bodyString = <span class="string">&quot;Base64[&quot;</span> + byteString.<span class="title function_">base64</span>() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="title function_">splitLine</span>(bodyString, <span class="string">&quot;|    &quot;</span>)).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> toString = responseBody.<span class="title function_">toString</span>();</span><br><span class="line">                logString.<span class="title function_">append</span>(<span class="string">&quot;|  &quot;</span> + <span class="string">&quot;respone body [Unknow Type] : &quot;</span> + responseBody.<span class="property">$className</span> + <span class="string">&quot; toString:&quot;</span> + toString).<span class="title function_">append</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(logString);     <span class="comment">// 最好是跟python交互，把数据发过去，这里打印很容易让app崩</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Java</span>.<span class="property">available</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;available&quot;</span>);</span><br><span class="line">    <span class="title function_">main</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果不错<br><img src="1.jpg"></p><h1 id="其它字节系app抓包"><a href="#其它字节系app抓包" class="headerlink" title="其它字节系app抓包"></a>其它字节系app抓包</h1><hr><p>再用中间人抓包方式抓番茄免费小说和番茄畅听，看到报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">W System.err: com.bytedance.frameworks.baselib.network.http.cronet.impl.CronetIOException: :0|Exception in CronetUrlRequest: net::ERR_CERT_AUTHORITY_INVALID, ip=:0, details=&#123;&quot;has_upload&quot;:false,&quot;is_pending&quot;:true,&quot;load_flags&quot;:16,&quot;load_state&quot;:3,&quot;method&quot;:&quot;GET&quot;,&quot;net_error&quot;:-202,&quot;network_isolation_key&quot;:&quot;null null&quot;,&quot;status&quot;:&quot;FAILED&quot;,&quot;traffic_annotation&quot;:77012883,&quot;url&quot;:&quot;https://mon.snssdk.com/monitor/appmonitor/v3/settings?sdk_version=400&amp;device_id&amp;app_version=56732&amp;package_name=com.dragon.read&amp;channel&amp;device_platform=android&amp;sdkmonitor_version=2.0.35&amp;aid=1792&amp;minor_version=1&amp;encrypt=close&quot;,&quot;url_chain&quot;:[&quot;https://mon.snssdk.com/monitor/appmonitor/v3/settings?sdk_version=400&amp;device_id&amp;app_version=56732&amp;package_name=com.dragon.read&amp;channel&amp;device_platform=android&amp;sdkmonitor_version=2.0.35&amp;aid=1792&amp;minor_version=1&amp;encrypt=close&quot;,&quot;https://mon11-misc-lq.fqnovel.com/monitor/appmonitor/v3/settings?sdk_version=400&amp;device_id&amp;app_version=56732&amp;package_name=com.dragon.read&amp;channel&amp;device_platform=android&amp;sdkmonitor_version=2.0.35&amp;aid=1792&amp;minor_version=1&amp;encrypt=close&quot;]&#125;, attempts= 116.55.252.177:443 result:-202 , dns=-1, connect=-1, ssl=-1, send=-1, proxy=-1, wait=-1, receive=-1, total=-1, reused=0, cached=0, response_content_len=0, total_bytes=0, is_proxy=0, QuicStreamError=0, QuicCloseSource=0, H2ProtocolError=-1, RFC7540Error=-1, ErrorCode=11, InternalErrorCode=-202, Retryable=false, ErrorCode=11, InternalErrorCode=-202, Retryable=false</span><br><span class="line">W System.err:    at com.bytedance.frameworks.baselib.network.http.cronet.impl.b.execute(SourceFile:524785)</span><br><span class="line">W System.err:    at com.bytedance.retrofit2.CallServerInterceptor.executeCall(SourceFile:33685512)</span><br><span class="line">W System.err:    at com.bytedance.retrofit2.CallServerInterceptor.intercept(SourceFile:17170588)</span><br><span class="line">W System.err:    at com.bytedance.retrofit2.intercept.RealInterceptorChain.proceed(SourceFile:17170550)</span><br><span class="line">W System.err:    at com.bytedance.frameworks.baselib.network.http.retrofit.b.intercept(SourceFile:17039402)</span><br><span class="line">W System.err:    at com.bytedance.retrofit2.intercept.RealInterceptorChain.proceed(SourceFile:17170550)</span><br><span class="line">W System.err:    at ms.bd.c.Pgl.h1$pgla.intercept(Unknown Source:14)</span><br></pre></td></tr></table></figure><p>那么就把脚本改成 hook <code>com.bytedance.frameworks.baselib.network.http.cronet.impl.b.execute</code></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>像这种有强大开发能力的大厂会实现自己的 http 请求库，常规的针对 okhttp 的 hook 就不管用了，如果想抓到明文包可以考虑找到 app 在 java 层收发包函数，然后 hook 打印。</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android抓包对抗总结</title>
      <link href="/2023/01/16/Android%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/16/Android%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结 Android 下的抓包对抗，方便下次做协议分析时翻出来看，算是个学习笔记，所以没什么新东西。</p><span id="more"></span><h1 id="全局代理检测"><a href="#全局代理检测" class="headerlink" title="全局代理检测"></a>全局代理检测</h1><hr><p>指的是通过 <code>adb shell settings put global http_proxy xxxx</code> 或者在 wifi 设置里配置全局代理</p><h2 id="检测实现："><a href="#检测实现：" class="headerlink" title="检测实现："></a>检测实现：</h2><ul><li>在构建 <code>OkHttpClient</code> 时配置 <code>Proxy.NO_PROXY</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHtppClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHtppClient</span>.Builder()</span><br><span class="line">                            .proxySelector(<span class="keyword">new</span> <span class="title class_">proxySelector</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Proxy&gt; <span class="title function_">select</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(Proxy.NO_PROXY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectFailed</span><span class="params">(URI uri, SocketAddress socketAddress, IOException e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><code>System.getProperty(&quot;http.proxyHost&quot;)</code> ，查看返回的是不是空字符串，不是则设置了全局代理</li></ul><h2 id="应对方法："><a href="#应对方法：" class="headerlink" title="应对方法："></a>应对方法：</h2><ul><li>hook 掉改成 <code>Proxy.getDefault</code></li><li>使用 vpn 代理</li></ul><h1 id="vpn代理检测"><a href="#vpn代理检测" class="headerlink" title="vpn代理检测"></a>vpn代理检测</h1><hr><p>实现：三种检测方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkByNetworkCapabilities</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConnectivityManager</span> <span class="variable">cm</span> <span class="operator">=</span> (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    Network[] networks = cm.getAllNetworks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; networks.length; i++) &#123;</span><br><span class="line">        <span class="type">NetworkCapabilities</span> <span class="variable">caps</span> <span class="operator">=</span> cm.getNetworkCapabilities(networks[i]);</span><br><span class="line">        <span class="keyword">assert</span> caps != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">transportVpn</span> <span class="operator">=</span> caps.hasTransport(NetworkCapabilities.TRANSPORT_VPN);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">notVpn</span> <span class="operator">=</span> caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN);</span><br><span class="line">        <span class="keyword">if</span> (transportVpn || !notVpn) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;[first] The VPN is active !&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;[first] no VPN !&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkByConnectivityManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConnectivityManager</span> <span class="variable">connectivityManager</span> <span class="operator">=</span> (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="type">NetworkInfo</span> <span class="variable">networkInfo</span> <span class="operator">=</span> connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_VPN);</span><br><span class="line">    <span class="keyword">assert</span> networkInfo != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(networkInfo.isConnected())&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;[second] The VPN is active !&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;[second] no VPN !&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkByInterfaceName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        <span class="keyword">while</span> (networkInterfaces.hasMoreElements())&#123;</span><br><span class="line">            <span class="type">NetworkInterface</span> <span class="variable">networkInterface</span> <span class="operator">=</span> networkInterfaces.nextElement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> networkInterface.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.contains(<span class="string">&quot;tun&quot;</span>) || name.equals(<span class="string">&quot;ppp0&quot;</span>))&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;[third]The VPN is active !&quot;</span> );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;[third] no VPN !&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应对方法：hook 绕过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> nc = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.net.NetworkCapabilities&#x27;</span>);</span><br><span class="line">        nc.<span class="property">hasTransport</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">param: any</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook hasTransport&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nc.<span class="property">hasCapability</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">param: any</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook hasCapability&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ni = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.net.NetworkInfo&quot;</span>);</span><br><span class="line">        ni.<span class="property">isConnected</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">param: any</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook isConnected&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> nic = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.net.NetworkInterface&#x27;</span>);</span><br><span class="line">        nic.<span class="property">getName</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">param: any</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook getName&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> name = <span class="variable language_">this</span>.<span class="title function_">getName</span>();</span><br><span class="line">            <span class="keyword">if</span> (name.<span class="title function_">indexOf</span>(<span class="string">&#x27;tun&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;tt&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&#x27;ppp0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;p0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="证书绑定（单向校验）"><a href="#证书绑定（单向校验）" class="headerlink" title="证书绑定（单向校验）"></a>证书绑定（单向校验）</h1><hr><p>实现：<br>先看看使用 OkHttpClient 做请求时怎么设置校验 server 证书</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">httpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .sslSocketFactory(factory, (X509TrustManager)trustManagerFactory.getTrustManagers()[<span class="number">0</span>])</span><br><span class="line">                .certificatePinner(certificatePinner)</span><br><span class="line">                .hostnameVerifier(<span class="keyword">new</span> <span class="title class_">myHostnameVerifier</span>())</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>主要有三个点：</p><ul><li>TrustManager</li><li>CertificatePinner</li><li>HostnameVerifier</li></ul><p>加载证书构建 <code>TrustManager</code> ，再创建 <code>SSLSocketFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取证书</span></span><br><span class="line"><span class="type">CertificateFactory</span> <span class="variable">certificateFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> getAssets().open(<span class="string">&quot;baidu.crt&quot;</span>);                             <span class="comment">// 这个证书是我在chrome导出的，而自签名证书可以用openssl生成</span></span><br><span class="line"><span class="type">Certificate</span> <span class="variable">ca</span> <span class="operator">=</span> certificateFactory.generateCertificate(stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将证书设置进入keystore</span></span><br><span class="line"><span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">keyStore.load(<span class="literal">null</span>);</span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;baidu&quot;</span>, ca);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建trustManagerFactory</span></span><br><span class="line"><span class="type">TrustManagerFactory</span> <span class="variable">trustManagerFactory</span> <span class="operator">=</span> TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">trustManagerFactory.init(keyStore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造SSLSocketFactory</span></span><br><span class="line"><span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">sslContext.init(<span class="literal">null</span>, trustManagerFactory.getTrustManagers(), <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());  <span class="comment">// 第一个参数是keyManager，双向校验时要设置这个参数 </span></span><br><span class="line"><span class="type">SSLSocketFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sslContext.getSocketFactory();</span><br></pre></td></tr></table></figure><p>创建 <code>CertificatePinner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CertificatePinner</span> <span class="variable">certificatePinner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CertificatePinner</span>.Builder()</span><br><span class="line">    .add(<span class="string">&quot;www.baidu.com&quot;</span>, CertificatePinner.pin(ca))    <span class="comment">// ca是Certificate对象</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>创建继承自 <code>HostnameVerifier</code> 的类，重载它的 verify 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">myHostnameVerifier</span> <span class="keyword">implements</span> <span class="title class_">HostnameVerifier</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String hostname, SSLSession session)</span> &#123;</span><br><span class="line">            <span class="comment">//这里写域名验证逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (hostname.equals(<span class="string">&quot;www.baidu.com&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Certificate[] peerCertificates = session.getPeerCertificates();</span><br><span class="line">                    <span class="type">Certificate</span> <span class="variable">peerCertificate</span> <span class="operator">=</span> peerCertificates[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (Arrays.equals(peerCertificate.getPublicKey().getEncoded(), ca.getPublicKey().getEncoded())) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么 okhttp 是怎么校验服务器证书的？整一份 okhttp3 的代码下来看看<br>，TCP 连接、SSL 握手和发包逻辑一般是在 Okhttp 的拦截器中实现的，既然是握手过程那么应该在 <code>ConnectInterceptor</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">HttpCodec</span> <span class="variable">httpCodec</span> <span class="operator">=</span> streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里省略掉中间的方法调用，直接来到关键点<br><code>okhttp3.internal.connection.RealConnection.connectTls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectTls</span><span class="params">(ConnectionSpecSelector connectionSpecSelector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Force handshake. This can throw!</span></span><br><span class="line">      sslSocket.startHandshake();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// Verify that the socket&#x27;s certificates are acceptable for the target host.</span></span><br><span class="line">      <span class="keyword">if</span> (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check that the certificate pinner is satisfied by the certificates presented.</span></span><br><span class="line">      address.certificatePinner().check(address.url().host(),</span><br><span class="line">          unverifiedHandshake.peerCertificates());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到 <code>connectTls</code> 方法，能看到调用了 <code>HostnameVerifier</code> 的 <code>verify</code> ，以及 <code>CertificatePinner</code> 的 <code>check</code> ，通过调试得知 <code>sslSocket</code> 是类 com.android.org.conscrypt.ConscryptFileDescriptorSocket 的对象，顺着 <code>startHandshake</code> 方法跟到 com.android.org.conscrypt.Platform.checkServerTrusted ，可以看到里面调用 <code>X509TrustManager</code> 的 <code>checkServerTrusted</code> 方法，它会在校验失败时抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkServerTrusted</span><span class="params">(X509TrustManager tm, X509Certificate[] chain,</span></span><br><span class="line"><span class="params">        String authType, AbstractConscryptSocket socket)</span> <span class="keyword">throws</span> CertificateException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        tm.checkServerTrusted(chain, authType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下 okhttp 做 server 证书校验的三个关键点：</p><ul><li>TrustManager 的 checkServerTrusted</li><li>CertificatePinner 的 check</li><li>hostnameVerifier 的 verify</li></ul><p>应对方法：<br>针对在实现方法中提到的三个点去做 hook ，基本能过掉 okhttp 的证书绑定</p><p>现成的 frida 脚本：</p><blockquote><p><a href="https://github.com/bxl0608/okhttp-sslunpinning">绕过针对混淆Okhttp的证书绑定</a><br><a href="https://www.anquanke.com/post/id/86507">使用加载了自己证书的SSLSocketFactory</a><br><a href="https://codeshare.frida.re/@akabe1/frida-multiple-unpinning/">frida版JustTrustMe</a></p></blockquote><h1 id="证书绑定（双向校验）"><a href="#证书绑定（双向校验）" class="headerlink" title="证书绑定（双向校验）"></a>证书绑定（双向校验）</h1><hr><p>实现：<br>服务端证书设置到 trustManagers ，客户端证书设置到 keyManagers</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KeyManagerFactory</span> <span class="variable">keyManagerFactory</span> <span class="operator">=</span> KeyManagerFactory.getInstance(SUN_X_509);</span><br><span class="line"><span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);     <span class="comment">// 证书类型为P12</span></span><br><span class="line">keyStore.load(keystore, <span class="string">&quot;password&quot;</span>);                    <span class="comment">//.P12证书密码</span></span><br><span class="line">keyManagerFactory.init(keyStore);</span><br><span class="line"><span class="comment">// 设置第一个参数keyManagers</span></span><br><span class="line">sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br></pre></td></tr></table></figure><p>应对方法：</p><ul><li>用<a href="https://github.com/r0ysue/r0capture">r0capture</a>，在 r0capture 中 hook 类 <code>java.security.KeyStore$PrivateKeyEntry</code> 的 <code>getPrivateKey</code> 方法和 <code>getCertificateChain</code> 方法 dump 出客户端证书</li><li>透明代理抓包：<blockquote><ol><li><a href="https://blog.seeflower.dev/archives/207/">安卓上基于透明代理对特定APP抓包</a>  </li><li><a href="https://blog.seeflower.dev/archives/210/#">[Clash版]安卓上基于透明代理抓包</a></li></ol></blockquote></li><li>使用 tcpdump ，需要参考这篇文章针对某一个 app 而不是网卡流量抓包：<a href="https://mp.weixin.qq.com/s?__biz=MzA3MzU1MDQwOA==&mid=2247484053&idx=1&sn=8b9dd1ad310f0c602bfde12be360a688&scene=21#wechat_redirect">终端应用安全之网络流量分析</a>，再配合<a href="https://www.52pojie.cn/thread-1405917-1-1.html">抓取SSL对称加密key</a>拿到握手过程协商的 key ，就可以在 wireshark 上看到明文 https 数据</li></ul><h1 id="底层抓包"><a href="#底层抓包" class="headerlink" title="底层抓包"></a>底层抓包</h1><hr><p>面对一个有抓包检测的 app ，不便于找到所有检测的地方，于是会在收发包调用链选择更底层的 java 方法或 native 函数，选择 hook 或者修改源码的方式记录收发包的情况，下面这篇就整理出了几个 hook 点</p><p><a href="https://bbs.kanxue.com/thread-267940.htm">[原创]android抓包学习的整理和归纳</a></p><p>根据这篇文章的 hook 点画几张图，看起来直观些</p><blockquote><p>java 层 http 发包</p></blockquote><p><img src="02.jpg"></p><blockquote><p>native 层 http 发包  </p></blockquote><p><img src="03.jpg"></p><blockquote><p>java 层 https 发包</p></blockquote><p><img src="04.jpg"></p><blockquote><p>native 层 https 发包</p></blockquote><p><img src="05.jpg"></p><p>这种方式抓出来的数据包可读性不强，可以考虑在接近业务逻辑的java层hook抓包</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>抓包是协议分析的第一步，注重安全的 app 都会在这设防，属于是兵家必争之地。文章记录了很多 hook 点，然而难的不是写代码 hook 这些点，难的是找到 hook 点，还是得多看源码和练习。</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Android内核初步绕过反调试</title>
      <link href="/2022/12/28/%E7%BC%96%E8%AF%91Android%E5%86%85%E6%A0%B8%E5%88%9D%E6%AD%A5%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
      <url>/2022/12/28/%E7%BC%96%E8%AF%91Android%E5%86%85%E6%A0%B8%E5%88%9D%E6%AD%A5%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>老早就想用改源码的方式绕过 tracepid 这类反调试检测，以前试过 patch boot.img 也没成功，凑巧最近编译 aosp 源码做脱壳机，就顺便把内核也改掉。主要参考这篇文章：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/CC40CwUS6jwNTc_by1zPlA">native层安卓_来自高纬的对抗：定制安卓内核过反调试</a></p></blockquote><span id="more"></span><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><hr><p>设备：Pixel<br>系统：Android 8.1.0<br>架构：arm64-v8a<br>编译机：Ubuntu 18</p><h2 id="编译内核源码"><a href="#编译内核源码" class="headerlink" title="编译内核源码"></a>编译内核源码</h2><hr><p>下载内核源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> msm</span></span><br></pre></td></tr></table></figure><p>手机 <code>adb shell</code> 执行 <code>cat /proc/version</code> 查看内核版本</p><p><img src="1.jpg"></p><p>检出对应版本代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 520f6eb</span></span><br></pre></td></tr></table></figure><p>准备编译环境变量，编译工具链在 aosp 源码中有，如果之前同步过 aosp ，那么这里直接用就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/&lt;user&gt;/Downloads/aosp/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> ARCH=arm64</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-android-</span></span><br></pre></td></tr></table></figure><p>开始编译，这一步生成 dtb 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make marlin_defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>接下来这一步生成 boot.img 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入aosp源码目录，执行这两条命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> TARGET_PREBUILT_KERNEL=/home/&lt;user&gt;/Downloads/kernel/msm/arch/arm64/boot/Image.lz4-dtb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make bootimage</span></span><br></pre></td></tr></table></figure><p>img 文件在 aosp 的 out&#x2F;target&#x2F;product&#x2F;sailfish ，进入该目录执行<br><code>fastboot flash boot boot.img</code></p><h2 id="修改内核绕过tracerpid检测"><a href="#修改内核绕过tracerpid检测" class="headerlink" title="修改内核绕过tracerpid检测"></a>修改内核绕过tracerpid检测</h2><hr><p>第一处修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/proc/base.c b/fs/proc/base.c</span><br><span class="line">index <span class="number">7</span>eb754c85482.<span class="number">.481</span>f8ee12b52 <span class="number">100644</span></span><br><span class="line">--- a/fs/proc/base.c</span><br><span class="line">+++ b/fs/proc/base.c</span><br><span class="line">@@ <span class="number">-245</span>,<span class="number">7</span> +<span class="number">245</span>,<span class="number">13</span> @@ <span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_pid_wchan</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> pid_namespace *ns,</span></span><br><span class="line"><span class="params">                <span class="keyword">else</span></span></span><br><span class="line"><span class="params">                        <span class="keyword">return</span> seq_printf(m, <span class="string">&quot;%lu&quot;</span>, wchan);</span></span><br><span class="line"><span class="params">        <span class="keyword">else</span></span></span><br><span class="line"><span class="params">+       &#123;</span></span><br><span class="line"><span class="params">+               <span class="keyword">if</span> (<span class="built_in">strstr</span>(symname, <span class="string">&quot;trace&quot;</span>)) </span></span><br><span class="line"><span class="params">+               &#123;</span></span><br><span class="line"><span class="params">+                   <span class="keyword">return</span> seq_printf(m, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;sys_epoll_wait&quot;</span>);</span></span><br><span class="line"><span class="params">+               &#125;</span></span><br><span class="line"><span class="params">                <span class="keyword">return</span> seq_printf(m, <span class="string">&quot;%s&quot;</span>, symname);</span></span><br><span class="line"><span class="params">+       &#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来两处修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/proc/<span class="built_in">array</span>.c b/fs/proc/<span class="built_in">array</span>.c</span><br><span class="line">index <span class="number">5699b</span>3c76d6f..a6dfe36f5621 <span class="number">100644</span></span><br><span class="line">--- a/fs/proc/<span class="built_in">array</span>.c</span><br><span class="line">+++ b/fs/proc/<span class="built_in">array</span>.c</span><br><span class="line">@@ <span class="number">-136</span>,<span class="number">10</span> +<span class="number">136</span>,<span class="number">10</span> @@ <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line">        <span class="string">&quot;R (running)&quot;</span>,          <span class="comment">/*   0 */</span></span><br><span class="line">        <span class="string">&quot;S (sleeping)&quot;</span>,         <span class="comment">/*   1 */</span></span><br><span class="line">        <span class="string">&quot;D (disk sleep)&quot;</span>,       <span class="comment">/*   2 */</span></span><br><span class="line">-       <span class="string">&quot;T (stopped)&quot;</span>,          <span class="comment">/*   4 */</span></span><br><span class="line">-       <span class="string">&quot;t (tracing stop)&quot;</span>,     <span class="comment">/*   8 */</span></span><br><span class="line">+       <span class="string">&quot;S (sleeping)&quot;</span>,         <span class="comment">/*   4 */</span></span><br><span class="line">+       <span class="string">&quot;S (sleeping)&quot;</span>,         <span class="comment">/*   8 */</span></span><br><span class="line">        <span class="string">&quot;X (dead)&quot;</span>,             <span class="comment">/*  16 */</span></span><br><span class="line">-       <span class="string">&quot;Z (zombie)&quot;</span>,           <span class="comment">/*  32 */</span></span><br><span class="line">+       <span class="string">&quot;S (sleeping)&quot;</span>,         <span class="comment">/*  32 */</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-183</span>,<span class="number">7</span> +<span class="number">183</span>,<span class="number">7</span> @@ <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">task_state</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> pid_namespace *ns,</span></span><br><span class="line"><span class="params">                get_task_state(p),</span></span><br><span class="line"><span class="params">                leader ? task_pid_nr_ns(leader, ns) : <span class="number">0</span>,</span></span><br><span class="line"><span class="params">                pid_nr_ns(pid, ns),</span></span><br><span class="line"><span class="params">-               ppid, tpid,</span></span><br><span class="line"><span class="params">+               ppid, <span class="number">0</span>,</span></span><br><span class="line"><span class="params">                from_kuid_munged(user_ns, cred-&gt;uid),</span></span><br><span class="line"><span class="params">                from_kuid_munged(user_ns, cred-&gt;euid),</span></span><br><span class="line"><span class="params">                from_kuid_munged(user_ns, cred-&gt;suid),</span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure><p>修改后重新编译刷入手机<br>TracerPid 恒为 0 ，State 是 sleeping</p><p><img src="2.jpg"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><hr><p>这种方式只能过掉部分反调试，对于像是双进程 ptrace ，时间检测，信号反调试这种还得特殊处理。</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anti-debug </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux虚拟机搭建Android逆向环境</title>
      <link href="/2022/11/25/archlinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAandroid%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/11/25/archlinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAandroid%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>r0env 作为 android 逆向环境已经相当完美了，之所以还要折腾 Archlinux 搭建新环境只是觉得 kali 上自带的各种渗透工具都是我不需要的，而我这种洁癖无法忍受这一点，于是找到这个最干净（可能）的 linux 系统，从零开始搭建，同时整理出这篇备忘文章。</p><span id="more"></span><h1 id="前期配置"><a href="#前期配置" class="headerlink" title="前期配置"></a>前期配置</h1><hr><p>首先从官网下载镜像，找到 China 那块随便找一个仓库下就行：<a href="https://archlinux.org/download/">iso下载地址</a><br>创建虚拟机没什么好说的，操作系统版本选择”其他Linux”，硬盘大小给的 70G ，网络适配器选择 NAT（桥接也行，需要配置一下静态 ip ），然后创建完成后进入虚拟机设置-&gt;选项-&gt;高级-&gt;固件类型选择UEFI</p><p><img src="1.jpg"></p><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><hr><p>开始安装系统，进入到 shell 界面后发现无法复制粘贴指令，使用宿主机的 cmder 自带的 ssh 连进虚拟机，先敲 <code>passwd root</code> 修改 root 的密码，然后敲 <code>ip addr</code> 命令查看自动分配的 ip ，最后再在 cmder 敲 <code>ssh root@&lt;your-ip&gt;</code></p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>创建分区的过程参考：<a href="https://blog.csdn.net/lxyoucan/article/details/115226297">2021年vmware安装archlinux</a><br>我自己创建了三个分区，第一个是 EFI ，第二个是 swap ，最后一个分区就是给根目录&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Device       Start       End   Sectors  Size Type</span><br><span class="line">/dev/sda1     2048    616447    614400  300M EFI System</span><br><span class="line">/dev/sda2   616448   4810751   4194304    2G Linux swap</span><br><span class="line">/dev/sda3  4810752 146798591 141987840 67.7G Linux filesystem</span><br></pre></td></tr></table></figure><p>格式化分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.fat -F 32 /dev/sda1    <span class="comment"># 格式化EFI系统分区</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkswap /dev/sda2            <span class="comment"># 格式化swap分区</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.ext4 /dev/sda3         <span class="comment"># 格式化根目录分区</span></span>  </span><br></pre></td></tr></table></figure><p>挂载分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount /dev/sda3 /mnt        <span class="comment"># 先挂载根目录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /mnt/boot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount /dev/sda1 /mnt/boot   <span class="comment"># 挂载EFI</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapon /dev/sda2            <span class="comment"># 挂载交换分区</span></span></span><br></pre></td></tr></table></figure><h2 id="安装必要软件包"><a href="#安装必要软件包" class="headerlink" title="安装必要软件包"></a>安装必要软件包</h2><p>修改 <code>/etc/pacman.d/mirrorlist</code> ，添加下面两项到顶部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.hit.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>安装真实系统所需的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacstrap /mnt base linux linux-firmware vim sudo dhcpcd bash-completion</span></span><br></pre></td></tr></table></figure><h2 id="生成fstab"><a href="#生成fstab" class="headerlink" title="生成fstab"></a>生成fstab</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span></span><br></pre></td></tr></table></figure><h2 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">arch-chroot /mnt         <span class="comment"># 进入安装的新系统</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -S grub efibootmgr</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub-mkconfig -o /boot/grub/grub.cfg</span></span><br></pre></td></tr></table></figure><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     <span class="comment"># 修改时区</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hwclock --systohc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/locale.gen      <span class="comment"># 本地化，去掉en_US.UTF-8 UTF-8行以及 zh_CN.UTF-8 UTF-8的注释符号</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">locale-gen</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;LANG=en_US.UTF-8&#x27;</span>  &gt; /etc/locale.conf</span></span><br></pre></td></tr></table></figure><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">passwd root         <span class="comment"># 先设置密码</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span>                <span class="comment"># 退回安装环境#</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">umount -R  /mnt     <span class="comment"># 卸载新分区</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot              <span class="comment"># 重启</span></span></span><br></pre></td></tr></table></figure><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>重启后就进入到真实的系统中了，首先需要为其配置网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> dhcpcd  <span class="comment">#设置开机启动</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl start dhcpcd  <span class="comment">#立即启动dhcp</span></span></span><br></pre></td></tr></table></figure><h2 id="设置源"><a href="#设置源" class="headerlink" title="设置源"></a>设置源</h2><p>修改 <code>/etc/pacman.d/mirrorlist</code> ，添加下面两项到顶部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.hit.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><h2 id="安装openssh"><a href="#安装openssh" class="headerlink" title="安装openssh"></a>安装openssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -S openssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/ssh/sshd_config        <span class="comment"># 修改允许root登录：PermitRootLogin yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> sshd.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl start sshd.service</span></span><br></pre></td></tr></table></figure><p>到这一步，一个纯净的不带界面的系统已经安装完成了，可以打个快照</p><h2 id="图形界面安装"><a href="#图形界面安装" class="headerlink" title="图形界面安装"></a>图形界面安装</h2><p>安装显卡驱动，需要先查表</p><p><img src="arch-driver.jpg"></p><p>以 intel 为例：<code>pacman -S xf86-video-intel</code><br>添加新用户，欢迎界面的可选用户不能是 root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">useradd -m &lt;user-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">passwd &lt;user-name&gt;</span></span><br></pre></td></tr></table></figure><p>将用户添加到 sudo 文件：<code>vim /etc/sudoers</code><br>在 <code>root    ALL=(ALL)       ALL </code> 下面一行添加 <code>&lt;user-name&gt;  ALL=(ALL)       ALL</code></p><p>开启 multilib 支持，到 &#x2F;etc&#x2F;pacman.conf ，取消下面两句的注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>继续在 &#x2F;etc&#x2F;pacman.conf 末尾添加 Arch Linux 中文社区仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>安装 KDE Plasma 桌面环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -Syyu              <span class="comment"># 更新一下仓库</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -S plasma-meta konsole dolphin</span>     </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> sddm     <span class="comment"># 开启sddm守护进程</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot                    <span class="comment"># 重启后就能看到图形界面</span></span></span><br></pre></td></tr></table></figure><h2 id="自适应窗口"><a href="#自适应窗口" class="headerlink" title="自适应窗口"></a>自适应窗口</h2><p>一般来说在虚拟机里面安装 VMware tools 就能解决窗口自适应的问题，但 Archlinux 好像对 VMware tools 的支持不太好，最后我是参考这篇文章解决的：<a href="http://blog.ccyg.studio/article/4a73a69f-2aaf-4c50-89a8-0bdd0149f7d8/">VMWare 自动适配 Archlinux 分辨率</a></p><h2 id="拖拽与复制粘贴"><a href="#拖拽与复制粘贴" class="headerlink" title="拖拽与复制粘贴"></a>拖拽与复制粘贴</h2><p>虚拟机与宿主机之间的复制粘贴</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S open-vm-tools</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S gtkmm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure><h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> --now NetworkManager        <span class="comment"># 先把桌面环境下的网络管理器跑起</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S wqy-zenhei       <span class="comment"># 安装文泉驿中文字体</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S fcitx5-im</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S fcitx5-chinese-addons</span></span><br></pre></td></tr></table></figure><p>编辑 <code>/etc/environment</code> ，添加下面的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INPUT_METHOD=fcitx5</span><br><span class="line">GTK_IM_MODULE=fcitx5</span><br><span class="line">QT_IM_MODULE=fcitx5</span><br><span class="line">XMODIFIERS=\@im=fcitx5</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure><p>接着添加中文输入法 <code>settings</code> &gt; <code>Regional Settings</code> &gt; <code>Input Method</code></p><p><img src="3.jpg"></p><p><img src="4.jpg"></p><p>之后按 <code>ctrl + space</code> 切换中文输入法</p><h2 id="安装paru（AUR助手）"><a href="#安装paru（AUR助手）" class="headerlink" title="安装paru（AUR助手）"></a>安装paru（AUR助手）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -Syu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S archlinuxcn-keyring  <span class="comment"># 更新GPG密钥</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S paru</span></span><br></pre></td></tr></table></figure><h2 id="安装常用工具"><a href="#安装常用工具" class="headerlink" title="安装常用工具"></a>安装常用工具</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S base-devel         <span class="comment"># 基础命令（which、find和grep）</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S chromium           <span class="comment"># chrome浏览器</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pacman -S scrcpy</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">paru -S visual-studio-code-bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">paru -S htop                      <span class="comment"># 内存进程监控</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">paru -S jnettop                   <span class="comment"># 网络监控</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">paru -S ark                       <span class="comment"># 压缩工具</span></span></span><br></pre></td></tr></table></figure><h2 id="zsh-安装和配置"><a href="#zsh-安装和配置" class="headerlink" title="zsh 安装和配置"></a>zsh 安装和配置</h2><p>安装zsh：<a href="https://arch.icekylin.online/advanced/optional-cfg-1.html#%F0%9F%9A%80-zsh">archlinux 简明指南</a></p><p>安装 zsh 后按键 Home 和 End 失效：<a href="https://conanblog.me/blog/2012/08/20/resolve-zsh-home-and-end-key-problem/">解决办法</a></p><p>修改 zsh prompt 格式，添加下面内容到 ~&#x2F;.zshrc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autoload -U colors &amp;&amp; colors</span><br><span class="line">PS1=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%~ %&#123;$reset_color%&#125;%% &quot;</span><br></pre></td></tr></table></figure><h1 id="逆向环境安装"><a href="#逆向环境安装" class="headerlink" title="逆向环境安装"></a>逆向环境安装</h1><hr><h2 id="安装jadx"><a href="#安装jadx" class="headerlink" title="安装jadx"></a>安装jadx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">paru -S jadx-bin</span></span><br></pre></td></tr></table></figure><h2 id="010editor"><a href="#010editor" class="headerlink" title="010editor"></a>010editor</h2><p>这样安装的只是30天试用版，也可以用52盘的破解版<br><code>paru -S 010editor</code></p><h2 id="python环境"><a href="#python环境" class="headerlink" title="python环境"></a>python环境</h2><p>安装 pyenv 以及 python2 和 python3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S pyenv</span><br><span class="line">$ wget &quot;https://mirrors.huaweicloud.com/python/2.7.18/Python-2.7.18.tar.xz&quot; -P ~/.pyenv/cache/; pyenv install 2.7.18</span><br><span class="line">$ wget &quot;https://mirrors.huaweicloud.com/python/3.8.0/Python-3.8.0.tar.xz&quot; -P ~/.pyenv/cache/; pyenv install 3.8.0</span><br><span class="line">$ wget &quot;https://mirrors.huaweicloud.com/python/3.8.5/Python-3.8.5.tar.xz&quot; -P ~/.pyenv/cache/; pyenv install 3.8.5</span><br></pre></td></tr></table></figure><p>配置 pyenv shell 环境<br><code>pyenv init</code><br>init 后会提示在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 写入下面内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure><p>重启 shell 环境<br><code>source ~/.zshrc</code><br>切换到拥有 python3.8.5 的环境，这个环境同时拥有 pip3<br><code>pyenv shell 3.8.5</code></p><h2 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h2><p>使用 <code>paru -S charles</code> 安装报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/xk72/charles/gui/MainWithClassLoader has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0</span><br></pre></td></tr></table></figure><p>查看所有 jdk 版本：<code>archlinux-java status</code><br>我的显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available Java environments:</span><br><span class="line">  java-19-openjdk</span><br><span class="line">  java-8-openjdk (default)</span><br></pre></td></tr></table></figure><p>切换 jdk 版本，不使用 java-8-openjdk ：<br><code>sudo archlinux-java set java-19-openjdk</code><br>如果没有就安装一个：<code>sudo pacman -S jre-openjdk</code><br>最后再用 paru 重新安装 charles</p><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><p>安装 nvm ，用于 nodejs 版本管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">paru -S nvm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;source /usr/share/nvm/init-nvm.sh&#x27;</span> &gt;&gt; ~/.bashrc   <span class="comment"># 如果是zshell就执行：echo &#x27;source /usr/share/nvm/init-nvm.sh&#x27; &gt;&gt; ~/.zshrc</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.zshrc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm ls-remote   <span class="comment"># 查看可用的node版本</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm install v16.18.1    <span class="comment"># 我选择了16.18.1</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm use v16.18.1    <span class="comment"># 切换版本</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm current         <span class="comment"># 查看当前版本</span></span></span><br></pre></td></tr></table></figure><h2 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h2><p>假设前面正确配置 pyenv 环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv <span class="built_in">local</span> 3.8.5</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install frida==14.2.18</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install frida-tools==9.2.4</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install objection==1.11.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv <span class="built_in">local</span> 3.8.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install frida==12.8.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install frida-tools==5.3.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install objection==1.8.4</span></span><br></pre></td></tr></table></figure><p>frida 项目开发环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://github.com/oleavr/frida-agent-example.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> frida-agent-example/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install --save @types/frida-gum     <span class="comment"># 编辑时有代码提示</span></span></span><br></pre></td></tr></table></figure><h2 id="android-studio"><a href="#android-studio" class="headerlink" title="android studio"></a>android studio</h2><p>使用 AUR 下载的是最新版，我想找个老版本的<br>访问↓网址选择一个版本然后 wget 即可<br><a href="https://developer.android.com/studio/archive">https://developer.android.com/studio/archive</a></p><p>添加别名，之后用 <code>as</code> 命令就能启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/profile</span></span><br><span class="line">export ANDROID_STUDIO_PATH=/path/to/android-studio</span><br><span class="line">alias as=&#x27;bash $ANDROID_STUDIO_PATH/bin/studio.sh&#x27;</span><br></pre></td></tr></table></figure><p>最后 source 一下<br><code>source /etc/profile</code></p><h2 id="jeb"><a href="#jeb" class="headerlink" title="jeb"></a>jeb</h2><p>找了半天不是跑不了，就是 license 过期，最后找到这个可以用的：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1699523&highlight=jeb">jeb下载地址</a></p><p>解压后执行 <code>jeb_linux</code> ，显示下图窗口，点击 <code>Generate a Key</code> ，然后点击 <code>Continue</code> 即可</p><p><img src="5.jpg"></p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>建立 <code>ll</code> 命令，在 <code>/etc/profile</code> 添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ll=&#x27;ls -al&#x27;</span><br></pre></td></tr></table></figure><p>安装 scrcpy<br><code>sudo pacman -S scrcpy</code></p><p>修改全局字体大小，全改成 12px<br><code>Setting</code> -&gt; <code>Appearance</code> -&gt; <code>Fonts</code></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>这一套搭建下来太麻烦了，不过成品效果还不错</p><p><img src="6.jpg"></p><p>ida 和 hyperpwn 有点难搞，就不装上去了，暂时先用着这些，以后有什么问题再说。。。累死</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bangbang加固企业版分析（下）</title>
      <link href="/2022/11/24/bangbang%E5%8A%A0%E5%9B%BA%E4%BC%81%E4%B8%9A%E7%89%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/11/24/bangbang%E5%8A%A0%E5%9B%BA%E4%BC%81%E4%B8%9A%E7%89%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接着上文的 bb 加固分析，接下来要去弄明白它的 VMP 指令如何执行的。</p><span id="more"></span><h1 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h1><hr><p>设备：Nexus 5<br>系统：Android 6<br>架构：armeabi-v7a<br><br></p><h1 id="Java层vmp入口"><a href="#Java层vmp入口" class="headerlink" title="Java层vmp入口"></a>Java层vmp入口</h1><hr><p>bb 加固的 VMP 属于 <code>DEX-VMP</code> ，原理大致是：</p><ul><li>修改 java 函数为 native ，vmp 实现在 native 层</li><li>执行时获取 java 函数对应的 codeitem ，获取参数信息，为参数的存放分配内存空间</li><li>找到 java 方法对应的 vmp 指令传入 vmpEntry 解析执行</li><li>在有需要调用 java 层函数的地方使用 jni 调用方式实现</li></ul><p>详细的内容可以参考<a href="https://geneblue.github.io/2019/09/13/android/sec--android-dex-vmp/">Android DEX-VMP 虚拟保护技术</a></p><p>根据上篇的分析 dump 出所有 dex 再合并成 apk 后再反编译，找到针对不同返回类型的 vmp 入口方法</p><p><img src="01.jpg"></p><p>vmp 的实现都在 libdexjni.so，因为要跑完 libDexHelper.so ，libdexjni.so 才会加载，而 libDexHelper 中又有内存解密和反调试，每次都手动绕过非常麻烦，所以为了方便动态调试，需要写 python 脚本辅助断到 libdexjni 的 JNI_OnLoad 。在上篇讲过 0x2A142 处的 <code>BLX R5</code> 指令会去执行反调试函数，里面都是扎堆的反调试逻辑，经过我的测试，只要把这段指令 <code>nop</code> 掉就能绕过反调试。<br>写一个继承自 idaapi.DBG_Hooks 的类，当 libDexHelper.so 加载时，在 init 函数结尾的地址下断点，获取然后 F9 执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dbg_library_load</span>(<span class="params">self, pid, tid, ea, name, base, size</span>):</span><br><span class="line">    <span class="keyword">if</span> name.find(self._target_library) != -<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">elif</span> name.find(<span class="string">&#x27;libDexHelper.so&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        self._helper_init = <span class="number">0xD06A8</span> + base          </span><br><span class="line">        self._helper_anti_dbg = <span class="number">0x2A142</span> + base      <span class="comment"># 反调试指令的地址</span></span><br><span class="line">        add_bpt(self._helper_init, <span class="number">0</span>, BPT_SOFT)     <span class="comment"># 在init函数结尾的地址下断点</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add bp on: &#x27;</span> + <span class="built_in">hex</span>(self._helper_init))</span><br><span class="line">        self.fn_f9()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.fn_f9()</span><br></pre></td></tr></table></figure><p>运行到 init 函数结尾说明 JNI_OnLoad 已经被解密出来，那么在反调试指令的前一条指令下断点然后继续执行，断下后可以把反调试指令 patch 掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dbg_bpt</span>(<span class="params">self, tid, ea</span>):</span><br><span class="line">    <span class="keyword">if</span> ea == self._helper_init:</span><br><span class="line">        del_bpt(ea)</span><br><span class="line">        add_bpt(self._helper_anti_dbg - <span class="number">2</span>, <span class="number">0</span>, BPT_SOFT) <span class="comment"># 断到反调试指令的前一条指令</span></span><br><span class="line">        self.fn_f9()</span><br><span class="line">    <span class="keyword">if</span> ea == self._helper_anti_dbg - <span class="number">2</span>:</span><br><span class="line">        idc.patch_word(self._helper_anti_dbg, <span class="number">0xBF00</span>)   <span class="comment"># 把反调试patch掉</span></span><br><span class="line">        del_bpt(ea)</span><br><span class="line">        self.fn_f9()</span><br></pre></td></tr></table></figure><p>继续执行 libdexjni.so 就被加载了，然后跟 libDexHelper.so 一样在 init 下断点等待 JNI_OnLoad 解密完成，执行过去就可以了</p><h1 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h1><hr><p>libdexjni 同样实现了 init 函数，跟上篇的 libDexHelper 一样解密 JNI_OnLoad ，这里就不细说了，dump 后直接看 JNI_OnLoad</p><p><img src="02.jpg"></p><p>伪代码中的部分函数调用被我重命名成 “jmp_xxx”，这些函数中的指令都是下图中这种取地址然后赋值给 PC 的强制跳转</p><p><img src="03.jpg"></p><p>JNI_OnLoad 前三个 jmp_xxx 函数解密 vmp 执行所需的指令及解密指令的 key ，进入 jmp_e0c8 函数看看，这里面首先是调用 sub_E368 反射获取 java 类及 methodId ，并把它们保存到全局变量上</p><p><img src="04.jpg"></p><p>接着注册 <code>com.fort.andjni.JniLib</code> 的所有 native 方法，后面以 cV 函数为例</p><p><img src="05.jpg"><br><img src="06.jpg"></p><h1 id="cV函数"><a href="#cV函数" class="headerlink" title="cV函数"></a>cV函数</h1><hr><p>cV 函数被注册到 sub_1416c ，看来 libdexjni 中也有 OLLVM</p><p><img src="07.jpg"></p><p>通过 trace 来到关键点 0x142A0 ，这里首先使用 jni 函数获取 cV 函数的最后一个参数，它是一个结构体数组的索引值，在 0x142C8 处调用函数计算并返回结构体地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">seg000:000142A0 180 30 68                   LDR             R0, [R6]</span><br><span class="line">seg000:000142A2 180 51 46                   MOV             R1, R10</span><br><span class="line">seg000:000142A4 180 D0 F8 AC 22             LDR.W           R2, [R0,#0x2AC]</span><br><span class="line">seg000:000142A8 180 30 46                   MOV             R0, R6</span><br><span class="line">seg000:000142AA 180 90 47                   BLX             R2                      ; GetArrayLength</span><br><span class="line">seg000:000142AC 180 31 68                   LDR             R1, [R6]</span><br><span class="line">seg000:000142AE 180 42 1E                   SUBS            R2, R0, #1</span><br><span class="line">seg000:000142B0 180 30 46                   MOV             R0, R6</span><br><span class="line">seg000:000142B2 180 01 92                   STR             R2, [SP,#0x180+var_17C]</span><br><span class="line">seg000:000142B4 180 D1 F8 B4 32             LDR.W           R3, [R1,#0x2B4]</span><br><span class="line">seg000:000142B8 180 51 46                   MOV             R1, R10</span><br><span class="line">seg000:000142BA 180 98 47                   BLX             R3                      ; 调用GetObjectArrayElement获取最后一个参数，这是一个索引值</span><br><span class="line">seg000:000142BC 180 D7 F8 B4 21             LDR.W           R2, [R7,#0x1B4]         ; method_id_intValue</span><br><span class="line">seg000:000142C0 180 01 46                   MOV             R1, R0</span><br><span class="line">seg000:000142C2 180 30 46                   MOV             R0, R6</span><br><span class="line">seg000:000142C4 180 F4 F7 70 EA             BLX             sub_87A8                ; _JNIEnv::CallIntMethod(_jobject *,_jmethodID *,...)</span><br><span class="line">seg000:000142C8 180 F4 F7 44 EA             BLX             j_153f0                 ; intValue返回值做下标从int型数组上取值</span><br><span class="line">seg000:000142CC 180 00 90                   STR             R0, [SP,#0x180+var_180]</span><br></pre></td></tr></table></figure><p>这里是根据 java 层传入的 <code>vmpId</code> 参数值来索引这块内存，结构体的定义如下图，将其称为 <code>vmpInfo</code> ，结构体第一个字段和传入的索引值相同，大胆猜测它是 vmpId ，第三个字段 <code>codeItem</code> 怎么来的？</p><p><img src="08.jpg"></p><h2 id="找到codeItem"><a href="#找到codeItem" class="headerlink" title="找到codeItem"></a>找到codeItem</h2><p>假设现在不知道 vmpInfo 结构体的具体定义，分析过程中遇到一块内存，不知道它的意义是很常见的事，我们要做的就是先放下往后看，然后倒推它的字段，有两篇文章值得参考<br></p><blockquote><p><a href="https://bbs.kanxue.com/thread-257061-1.htm">某企业级加固[四代壳]VMP解释执行+指令还原</a><br><a href="https://bbs.kanxue.com/thread-270799-1.htm">某DEX_VMP安全分析与还原</a></p></blockquote><p>前辈的思路就是根据 VMP-DEX 的特点断点 <code>jni</code> 函数，比如 <code>FindClass</code> ，然后倒推代码逻辑</p><p><img src="09.jpg"></p><p>断下 FindClass 看到它在找 <code>java/lang/Object</code> 类，jni 函数一般会由 vmpEntry 调用，所以此时的 LR 保存的地址属于 vmpEntry 函数的地址空间，顺着 LR 找到 vmpEntry 函数开头，偏移为 0x1D0B0</p><p><img src="10.jpg"></p><p>现在要做的是往 vmpEntry 函数开头方向追踪 FindClass 参数是怎么来的，为了方便分析需要用到上篇分析文章中的 trace 脚本，跟踪 vmpEntry 的执行并输出日志，R1 寄存器保存字符串地址，可以看到值来自 [[SP, #0x950]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(        libdexjni.so[0x9BF6663C])0x0002163C: LDR.W           R1, [SP,#0x950]</span><br><span class="line">(        libdexjni.so[0x9BF66640])0x00021640: LDR             R2, [R0]</span><br><span class="line">(        libdexjni.so[0x9BF66642])0x00021642: LDR             R1, [R1]                                              </span><br><span class="line">(        libdexjni.so[0x9BF66644])0x00021644: LDR             R2, [R2,#0x18]                                        </span><br><span class="line">(        libdexjni.so[0x9BF66646])0x00021646: BLX             R2                ; FindClass</span><br></pre></td></tr></table></figure><p>使用 trace 日志分析的一个好处就是能直接搜索 <code>[SP, #0x950]</code> ，看哪里对它赋值了，来到 0x3A942 调用函数后返回值赋值，理论上跟入这个函数看是哪里赋值 R0 即可，这里不展开了，函数内是从 <code>([GOT + 0xD8370 + 0xC] + R1 &lt;&lt; 2)</code> 地址上取出字符串，R1 即是 sub_9BF4DB14 的第二个参数，而 R1 在 0x3A93C 处被赋值，这是个关键值，因为它指导 sub_9BF4DB14 获取字符串，是个字符串索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(        libdexjni.so[0x9BF7F93C])0x0003A93C: LDR.W           R1, [SP,#0x9A4]</span><br><span class="line">(        libdexjni.so[0x9BF7F940])0x0003A940: MOV             R0, R4         </span><br><span class="line">(        libdexjni.so[0x9BF7F942])0x0003A942: BLX             sub_9BF4DB14   </span><br><span class="line">(        libdexjni.so[0x9BF7F946])0x0003A946: STR.W           R0, [SP,#0x950]</span><br></pre></td></tr></table></figure><p>继续往上追踪 <code>[SP,#0x9A4]</code> ，方法类似，这里直接给出结果：<code>字符串索引 = [[[R0]] + 2]</code> ，R0 是 vmpEntry 的第一个参数，又因为 insn 会指导程序到某处获取字符串，即字符串索引就在 insn 中，进一步可得 vmpEntry 的第一个参数就是 insn 的地址，指令是 <code>00 10 CB 28 00 00 47 00</code> ，往前偏移 16 字节是 codeItem 为 <code>01 00 01 00 01 00 00 00  16 38 09 00 04 00 00 00</code></p><p><img src="11.jpg"></p><p>看到 codeItem 最后 4 字节是 <code>04 00 00 00</code> ，对照 codeItem 结构体说明 insnsSize 为 4 ，即共有 4 条指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CodeItem</span> &#123;</span></span><br><span class="line">    uint16  registersSize;   </span><br><span class="line">    uint16  insSize;           </span><br><span class="line">    uint16  outsSize;</span><br><span class="line">    uint16  triesSize;</span><br><span class="line">    uint32  debugInfoOff;       </span><br><span class="line">    uint32  insnsSize;</span><br><span class="line">    uint16  insns[<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 sub_1416c ，在 0x14642 处调用函数进入 vmpEntry ，向上找 R0 的赋值，最后发现它来自 vmpInfo 结构体，偏移为 0x8 ，这就是通过回溯法推断出了 vmpInfo 上的 codeItem 字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(        libdexjni.so[0x9BF192CC])0x000142CC: STR             R0, [SP]              ; 保存vmpInfo</span><br><span class="line">...</span><br><span class="line">(        libdexjni.so[0x9BF1933A])0x0001433A: LDR             R1, [SP]              ; 取出vmpInfo</span><br><span class="line">...</span><br><span class="line">(        libdexjni.so[0x9BF19352])0x00014352: LDR             R0, [R1,#8]           ; vmpInfo偏移8字节处取出codeItem</span><br><span class="line">(        libdexjni.so[0x9BF19354])0x00014354: STR             R0, [SP,#0x13C]       ; 保存codeItem                            </span><br><span class="line">...</span><br><span class="line">(        libdexjni.so[0x9BF1962E])0x0001462E: LDR             R0, [SP,#0x13C]       ; 取出codeItem</span><br><span class="line">(        libdexjni.so[0x9BF19630])0x00014630: LDR             R1, [SP,#0x148] </span><br><span class="line">(        libdexjni.so[0x9BF19632])0x00014632: STR             R1, [R5,#0x1C]  </span><br><span class="line">(        libdexjni.so[0x9BF19634])0x00014634: ADDS            R0, #0x10       </span><br><span class="line">(        libdexjni.so[0x9BF19636])0x00014636: STR             R0, [R5]              ; insn保存到一个内存上</span><br><span class="line">(        libdexjni.so[0x9BF19638])0x00014638: ADD             R1, SP, #0x130  </span><br><span class="line">(        libdexjni.so[0x9BF1963A])0x0001463A: LDR             R4, [SP,#0x28]  </span><br><span class="line">(        libdexjni.so[0x9BF1963C])0x0001463C: MOV             R0, R5          </span><br><span class="line">(        libdexjni.so[0x9BF1963E])0x0001463E: LDR             R3, [SP,#0x154] </span><br><span class="line">(        libdexjni.so[0x9BF19640])0x00014640: MOV             R2, R4          </span><br><span class="line">(        libdexjni.so[0x9BF19642])0x00014642: BLX             sub_9BF0D730          ; vmpEntry</span><br></pre></td></tr></table></figure><h2 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h2><p>接下来要分析指令，若能看到寄存器的值会方便很多，所以重新修改 trace 脚本把寄存器值打印出来（像下面展示的汇编后面的D表示目的寄存器的值，S 表示源寄存器的值），然后搜索 insn 第一条指令 0x1000，能看到对它做了异或操作得到 0x1089 ，接着计算出跳转地址并跳转过去，往下就分别调用 FindClass 、GetMethodID 和 CallNonvirtualVoidMethodA ，所以 insn 前两个字节 0x1000 用于计算跳转 handle 的地址，而 0x28CB 是索引字符串的操作数，它就是传给 sub_9BF4DB14 的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(        libdexjni.so[0x9BEDF2CC])0x0002C2CC: LDRH            R6, [R6]                                              D: [R6: 0xB399E3B8] S: [R6: 0xB399E3B8]         ; 取insn前两字节</span><br><span class="line">(        libdexjni.so[0x9BEDF2CE])0x0002C2CE: ADD             R0, PC; _GLOBAL_OFFSET_TABLE_                         D: [R0: 0x3289E] S: [PC: 0x9BEDF2CE]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D0])0x0002C2D0: LDR.W           R3, [SP,#0x9E8]                                       D: [R3: 0xFFFFFFFC] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D4])0x0002C2D4: LDR             R2, [R7,R2]                                           D: [R2: 0x0] S: [R2: 0x0, R7: 0x9C0FD1C0]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D6])0x0002C2D6: ADD             R0, R1                                                D: [R0: 0x9BF11B70] S: [R1: 0xFFFFFA84]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D8])0x0002C2D8: EOR.W           R1, R2, R6                                            D: [R1: 0xFFFFFA84] S: [R2: 0x89, R6: 0x1000]   ; 0x1000在这里做异或操作</span><br><span class="line">(        libdexjni.so[0x9BEDF2DC])0x0002C2DC: STR.W           R1, [SP,#0x9D4]                                       D: [R1: 0x1089] S: [SP: 0xBEF721A8]             ; 这里看到异或的结果0x1089</span><br><span class="line">(        libdexjni.so[0x9BEDF2E0])0x0002C2E0: MOV.W           R6, #0x10A                                            D: [R6: 0x1000] S: []</span><br><span class="line">(        libdexjni.so[0x9BEDF2E4])0x0002C2E4: LDR.W           R2, [SP,#0x9E4]                                       D: [R2: 0x89] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEDF2E8])0x0002C2E8: UXTB            R1, R1                                                D: [R1: 0x1089] S: [R1: 0x1089]</span><br><span class="line">(        libdexjni.so[0x9BEDF2EA])0x0002C2EA: ADD.W           R0, R0, R1,LSL#2                                      D: [R0: 0x9BF115F4] S: [R0: 0x9BF115F4]</span><br><span class="line">(        libdexjni.so[0x9BEDF2EE])0x0002C2EE: LDR.W           R1, [SP,#0x9F4]                                       D: [R1: 0x89] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEDF2F2])0x0002C2F2: LDR             R0, [R0]                                              D: [R0: 0x9BF11818] S: [R0: 0x9BF11818]</span><br><span class="line">(        libdexjni.so[0x9BEDF2F4])0x0002C2F4: MOV             PC, R0                                                D: [PC: 0x9BEDF2F4] S: [R0: 0x9BEE6DB8]         ; 跳转</span><br></pre></td></tr></table></figure><p>断下 GetMethodID ，发现查找的是构造函数，结合 FindClass ，后面的 CallNonvirtualVoidMethodA 是在调用 <code>java/lang/Object</code> 类的 <code>&lt;init&gt;</code> 函数，猜测 insn 前两个字节代表 invoke 指令，结合这篇文章：<a href="https://doc.yonyoucloud.com/doc/wiki/project/jni-ndk-developer-guide/function2.html">JNI 调用构造方法和父类实例方法</a>，可以知道在 native 层调用父类构造方法用的就是 <code>CallNonvirtualVoidMethodA</code> 这个 jni 函数，进一步确定是 <code>invoke-super</code> 指令。</p><p><img src="12.jpg"></p><p><code>invoke</code> 指令还需要指定参数，比如下图的 <code>invoke-super</code> 使用了 v6 和 v7 寄存器，那么它的指令字节码最后两字节 <code>76 00</code> ，<code>invoke-static</code> 没有使用寄存器，于是最后两字节是 <code>00 00</code> ，而cV 调用的 <code>&lt;init&gt;</code> 函数参数为空，所以第三条指令是 0x0000</p><p><img src="13.jpg"></p><p>最后两个字节 0x0047 ，在 0x35F7C 处搜到 0x47 ，发现也是做了异或得到 0xC0 并且参与跳转地址的计算，所以断定它也是操作码，又因为它是最后一条指令且 cV 返回值为 void ，所以对应的指令是 <code>return-void</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(        libdexjni.so[0x9BEE8F70])0x00035F70: LDRH            R6, [R6]                                              D: [R6: 0xB399E3BE] S: [R6: 0xB399E3BE]         ; 取出最后一条指令</span><br><span class="line">(        libdexjni.so[0x9BEE8F72])0x00035F72: ADD             R0, PC; _GLOBAL_OFFSET_TABLE_                         D: [R0: 0x28BFA] S: [PC: 0x9BEE8F72]</span><br><span class="line">...</span><br><span class="line">(        libdexjni.so[0x9BEE8F7A])0x00035F7A: ADD             R0, R1                                                D: [R0: 0x9BF11B70] S: [R1: 0xFFFFFA84]</span><br><span class="line">(        libdexjni.so[0x9BEE8F7C])0x00035F7C: EOR.W           R1, R2, R6                                            D: [R1: 0xFFFFFA84] S: [R2: 0x87, R6: 0x47]     ; 0x47参与异或</span><br><span class="line">(        libdexjni.so[0x9BEE8F80])0x00035F80: STR.W           R1, [SP,#0x9D4]                                       D: [R1: 0xC0] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEE8F84])0x00035F84: MOV.W           R6, #0x10A                                            D: [R6: 0x47] S: []</span><br><span class="line">(        libdexjni.so[0x9BEE8F88])0x00035F88: LDR.W           R2, [SP,#0x9E4]                                       D: [R2: 0x87] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEE8F8C])0x00035F8C: UXTB            R1, R1                                                D: [R1: 0xC0] S: [R1: 0xC0]</span><br><span class="line">(        libdexjni.so[0x9BEE8F8E])0x00035F8E: ADD.W           R0, R0, R1,LSL#2                                      D: [R0: 0x9BF115F4] S: [R0: 0x9BF115F4]</span><br><span class="line">(        libdexjni.so[0x9BEE8F92])0x00035F92: LDR.W           R1, [SP,#0x9F4]                                       D: [R1: 0xC0] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEE8F96])0x00035F96: LDR             R0, [R0]                                              D: [R0: 0x9BF118F4] S: [R0: 0x9BF118F4]</span><br><span class="line">(        libdexjni.so[0x9BEE8F98])0x00035F98: MOV             PC, R0                                                D: [PC: 0x9BEE8F98] S: [R0: 0x9BEEA558]          ; 跳转</span><br></pre></td></tr></table></figure><p>到这里可以推出第一次执行 cV 函数指令的含义以及指令格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00 10     CB 28      00 00     47 00</span><br><span class="line">opcode    oprand     参数      opcode</span><br></pre></td></tr></table></figure><p>再看看第二次执行 cV 函数，0x1069 参与异或运算得到 0x1089 ，0x008B 参与异或运算得到 0x00C0 ，这个第一次执行 cV 函数得到的结果一样，说明传给 vmpEntry 的 insn 中只有 opcode 要做一次异或解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">69 10     CB 28      00 00     8B 00               </span><br><span class="line">opcode    oprand     参数      opcode</span><br></pre></td></tr></table></figure><p>第四次执行 cV 函数，<code>89 10 CB 28 01 00</code> 跟前面一样是 <code>invoke-super &#123;v1&#125;, Ljava/lang/Object;-&gt;$init</code> ，最后的 <code>C0 00</code> 也是 <code>return-void</code> ，那么 <code>75 00 00 00 F5 10 38 02</code> 是什么还得去看执行了哪些 jni 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5B 10 CB 28 01 00 41 00  00 00 DA 10 38 02 9D 00    // 解密前</span><br><span class="line"></span><br><span class="line">89 10 CB 28 01 00 75 00  00 00 F5 10 38 02 C0 00    // 解密后</span><br></pre></td></tr></table></figure><p>本次 vmpEntry 执行了 GetFieldID ，查找类 cn&#x2F;missfresh&#x2F;module&#x2F;base&#x2F;network&#x2F;a&#x2F;i 的域 a ，它是一个 jstring ，接着调用 <code>SetObjectField</code> 给它设置一个 string 值，那么对应的 smali 就是 <code>iput-object</code> ，前面已经得知这个壳的 vmp 指令格式与 Dalvik 虚拟机指令格式相同，那么参考一下格式</p><p><img src="15.jpg"></p><p><code>5b</code> 代表 <code>iput-object</code> ，紧跟着的一字节是寄存器，接着两字节用于索引 field ，回去看 vmp 指令，现在已经确定其中有代表 <code>iput-object</code> 的指令，然后前面得出结论 opcode 会做解密，所以只可能是 <code>75 00</code> 或 <code>F5 10</code> ，又因为它给字符串域赋值，需要先把字符串存在寄存器中，即会有 <code>const-string</code> 指令，那么得出 <code>75 00</code> 是 <code>const-string v0, &quot;xxx&quot;</code> ，<code>F5 10</code> 是 <code>iput-object v0, v1, Lxxx</code> 指令</p><p>其它指令分析类似，先拿到当前执行的指令，trace 整个执行流程，整理出哪几个指令被解密了，这些指令就是 opcode ，再找出调用的 jni 函数，通过 jni 函数可以猜出 smali ，猜不到就参考这个 dex2c 项目：<a href="https://github.com/amimo/dcc">dcc</a></p><h2 id="指令解密分析"><a href="#指令解密分析" class="headerlink" title="指令解密分析"></a>指令解密分析</h2><p>如果要写脚本修复 vmp 指令，还得找到异或解密 opcode 用到的 key 在哪保存，通过回溯 <code>EOR</code> 指令可知 key地址 &#x3D; [R7 + 当前执行insn地址 - insn基址]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(        libdexjni.so[0x9BEDF2BE])0x0002C2BE: SUBS            R2, R6, R2                                            D: [R2: 0xB399E3B8] S: [R6: 0xB399E3B8]     ; 当前执行insn地址 - insn基址</span><br><span class="line">(        libdexjni.so[0x9BEDF2C0])0x0002C2C0: LDR.W           R0, =(_GLOBAL_OFFSET_TABLE_ - 0x9BEDF2D2)             D: [R0: 0x0] S: []</span><br><span class="line">(        libdexjni.so[0x9BEDF2C4])0x0002C2C4: LDR.W           R1, =0xFFFFFA84                                       D: [R1: 0x0] S: []</span><br><span class="line">(        libdexjni.so[0x9BEDF2C8])0x0002C2C8: AND.W           R2, R3, R2,LSL#1                                      D: [R2: 0x0] S: [R3: 0xFFFFFFFC]</span><br><span class="line">(        libdexjni.so[0x9BEDF2CC])0x0002C2CC: LDRH            R6, [R6]                                              D: [R6: 0xB399E3B8] S: [R6: 0xB399E3B8]     ; 取insn前两字节</span><br><span class="line">(        libdexjni.so[0x9BEDF2CE])0x0002C2CE: ADD             R0, PC; _GLOBAL_OFFSET_TABLE_                         D: [R0: 0x3289E] S: [PC: 0x9BEDF2CE]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D0])0x0002C2D0: LDR.W           R3, [SP,#0x9E8]                                       D: [R3: 0xFFFFFFFC] S: [SP: 0xBEF721A8]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D4])0x0002C2D4: LDR             R2, [R7,R2]                                           D: [R2: 0x0] S: [R2: 0x0, R7: 0x9C0FD1C0]   ; R7是key表地址</span><br><span class="line">(        libdexjni.so[0x9BEDF2D6])0x0002C2D6: ADD             R0, R1                                                D: [R0: 0x9BF11B70] S: [R1: 0xFFFFFA84]</span><br><span class="line">(        libdexjni.so[0x9BEDF2D8])0x0002C2D8: EOR.W           R1, R2, R6                                            D: [R1: 0xFFFFFA84] S: [R2: 0x89, R6: 0x1000]</span><br></pre></td></tr></table></figure><p>再回溯得知 R7 是 key 表地址，由下面这个函数返回，地址计算公式：[[GOT + 0xD8C50 + 0x8] + vmpId * 4]</p><p><img src="14.jpg"></p><p>那么获取解密当前 opcode 的 key 地址的公式：[[[GOT + 0xD8C50 + 0x8] + vmpId * 4] + addr_cur_insn - addr_insn_base]</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>这个 vmp 壳的分析到这里先结束了，要解析出指令映射表需要很大的精力和时间，虽然同一个版本的指令映射表应该是一样的，但是在内存中的 vmp 指令是加密过的，增加了写 patch 的难度。第一次接触 vmp，也是一边学习别人的方法，一边自己尝试分析，ida 搭配 trace 日志分析 OLLVM 和 vmp 效果不错，可惜 ida 下不了内存断点，地址随机化也给分析带来麻烦，之后看看有没有办法解决这些问题。</p>]]></content>
      
      
      <categories>
          
          <category> Android加固分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bangbang加固企业版分析（上）</title>
      <link href="/2022/11/07/bangbang%E5%8A%A0%E5%9B%BA%E4%BC%81%E4%B8%9A%E7%89%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/11/07/bangbang%E5%8A%A0%E5%9B%BA%E4%BC%81%E4%B8%9A%E7%89%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>阅读了看雪上一篇对 android VMP 壳的反混淆思路文章:</p><blockquote><p><a href="https://bbs.pediy.com/thread-273614.htm">[原创]android so文件攻防实战-libDexHelper.so反混淆</a></p></blockquote><p>对于壳的功能作者并没有进行详细的阐述，看后感觉意犹未尽，而且这家厂商的壳分析文章在网上挺多的，以前简单分析过它的免费版，这次正好拿来作为 VMP 壳入门。因为内容过多，需要分为上下两篇。</p><span id="more"></span><h1 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h1><hr><p>设备：Nexus 5<br>系统：Android 6<br>架构：armeabi-v7a<br><br></p><h1 id="java层入口"><a href="#java层入口" class="headerlink" title="java层入口"></a>java层入口</h1><hr><p>先看有没有实现 application<br><img src="15.jpg"><br>实现了 application 就去看看它的 attachBaseContext ，加载了 libDexHelper.so<br><img src="16.jpg"><br>那么接下来就是分析 libDexHelper.so</p><h1 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h1><hr><p>从初始化函数开始分析，F5 失败，0xD0688 的地方分析失败</p><p><img src="01.jpg"></p><p>0xD0688 处调用了一个函数，进去后 F5 看到参数个数有点多，可能是函数参数声明不正确</p><p><img src="02.jpg"></p><p>结合上层函数的传参情况，对该函数的参数声明修改成如下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">sub_D0C30</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br></pre></td></tr></table></figure><p>然后对 sub_D0C30 这个函数 F5 会出现如下错误，这是因为函数中存在破坏堆栈的指令</p><p><img src="03.jpg"></p><p>解决办法参考下面这篇文章：</p><blockquote><p><a href="https://bbs.pediy.com/thread-158896.htm">[推荐]IDA sp-analysis failed 不能F5的 解决方案之(二)</a></p></blockquote><p>ida 中打开 <strong>Options</strong> -&gt; <strong>General</strong> -&gt; <strong>Stack pointer</strong> ，这样方便查看堆栈情况，根据函数首尾入栈与出栈找到破坏堆栈的一句指令，把它 nop 掉即可</p><p><img src="04.jpg"></p><p>回到 init 函数，现在可以 F5 了，两个函数的主要内容都在注释中写出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  sub_D0F50((<span class="type">int</span>)<span class="string">&quot;&quot;</span>);                           <span class="comment">// mmap内存，把段seg000的内容拷贝过去</span></span><br><span class="line">  sub_D0C30(<span class="string">&quot;&quot;</span>, (<span class="type">int</span>)&amp;dword_103D4, v0);         <span class="comment">// 解密</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 sub_D0C30 ，在该函数结尾的两个 <code>mprotect</code> 下断点，运行到断点处就能 dump 出解密后内存数据，第一个 mprotect 是修改代码段的权限，第二个 mprotect 是修改数据段的权限（包括 GOT 表），所以能够 dump 出解密后的代码段和数据段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">sub_D0C30</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  syscall_mprotect(</span><br><span class="line">    (<span class="type">void</span> *)((v12 + v23[<span class="number">2</span>] - <span class="number">4095</span>) &amp; <span class="number">0xFFFFF000</span>),</span><br><span class="line">    ((v23[<span class="number">5</span>] + <span class="number">4095</span> + v12 + v23[<span class="number">2</span>]) &amp; <span class="number">0xFFFFF000</span>) - ((v12 + v23[<span class="number">2</span>] - <span class="number">4095</span>) &amp; <span class="number">0xFFFFF000</span>),</span><br><span class="line">    <span class="number">3</span>);</span><br><span class="line">  sub_D0ADC((_DWORD *)(v12 + a1[<span class="number">6</span>]), v12 + a1[<span class="number">4</span>], a1[<span class="number">5</span>], v12);</span><br><span class="line">  syscall_mprotect((<span class="type">void</span> *)v12, v14, <span class="number">7</span>);</span><br><span class="line">  syscall_munmap((<span class="type">void</span> *)a3, v15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面还有一个 init 函数，自己调试了一下，逻辑就是判断当前进程是不是 dex2oat ，不太重要就不细说了<br><br></p><h1 id="JNI-OnLoad函数"><a href="#JNI-OnLoad函数" class="headerlink" title="JNI_OnLoad函数"></a>JNI_OnLoad函数</h1><hr><h2 id="OLLVM混淆"><a href="#OLLVM混淆" class="headerlink" title="OLLVM混淆"></a>OLLVM混淆</h2><p>JNI_Onload 做了平坦化混淆，网上有很多应对 OLLVM 的方法，我一般就直接在 ida 中 trace 出指令日志，然后分析日志</p><p><img src="05.jpg"></p><p>上一篇文章用 ida 提供的 trace 功能，出现跑飞的情况，而且我不想跟进函数调用，所以参考这位大佬的 trace 脚本自己改了一份：</p><blockquote><p><a href="https://bbs.pediy.com/thread-257878.htm">[原创]细说arm反类ollvm混淆-基本思想</a></p></blockquote><p>trace 脚本跟踪 JNI_Onload 的所有指令，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(     libDexHelper.so[0xAEF38000])[2D E9 F0 4F ]0x00028868:PUSH.W          &#123;R4-R11,LR&#125;</span><br><span class="line">(     libDexHelper.so[0xAEF38000])[AD F6 AC 4D ]0x0002886C:SUBW            SP, SP, #0xCAC</span><br><span class="line">(     libDexHelper.so[0xAEF38000])[8D 4C       ]0x00028870:LDR             R4, =(_GLOBAL_OFFSET_TABLE_ - 0xAEF6087C)</span><br><span class="line">(     libDexHelper.so[0xAEF38000])[00 22       ]0x00028872:MOVS            R2, #0    </span><br><span class="line">...</span><br><span class="line">(     libDexHelper.so[0xAEF38000])[11 D0       ]0x0002AC20:BEQ             loc_AEF62C46</span><br><span class="line">(     libDexHelper.so[0xAEF38000])[0D F6 AC 4D ]0x0002AC46:ADDW            SP, SP, #0xCAC</span><br><span class="line">(     libDexHelper.so[0xAEF38000])[BD E8 F0 8F ]0x0002AC4A:POP.W           &#123;R4-R11,PC&#125;</span><br></pre></td></tr></table></figure><p>接下来如果函数比较简单就分析日志找到关键的块下断点，复杂的话就用脚本从执行过的块中尽可能过滤掉虚假块，对剩下的真实块逐个分析，基本能把逻辑分析出来。具体就不展开了，绕过 OLLVM 不是本篇的内容。<br>像下面这样把真实块打印出来，index 表示执行的顺序，ea 表示块的偏移地址，接下来就是对这些块进行漫长分析.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----relevant-block------</span><br><span class="line">index: 0, start ea: 0x28868</span><br><span class="line">index: 2, start ea: 0x288ae</span><br><span class="line">index: 3, start ea: 0x288b2</span><br><span class="line">...</span><br><span class="line">index: 116, start ea: 0x2a5ae</span><br><span class="line">index: 117, start ea: 0x2ac16</span><br><span class="line">index: 118, start ea: 0x2ac46</span><br></pre></td></tr></table></figure><h2 id="注册java方法"><a href="#注册java方法" class="headerlink" title="注册java方法"></a>注册java方法</h2><p>0x2A024 处调用 <code>RegisterNatives</code> 注册 <code>com/secneo/apkwrapper/H</code> 的所有 native 方法，整理出 java 方法对应的 native 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;attach&quot;: sub_2775C</span><br><span class="line">&quot;b&quot;: sub_17210</span><br><span class="line">&quot;c&quot;: sub_18B10</span><br><span class="line">&quot;d&quot;: sub_20384</span><br><span class="line">&quot;e&quot;: sub_224A0</span><br><span class="line">&quot;f&quot;: sub_1CE90</span><br><span class="line">&quot;g&quot;: sub_1CA30</span><br><span class="line">&quot;h&quot;: sub_1C420</span><br><span class="line">&quot;n&quot;: sub_1BF1C</span><br><span class="line">&quot;j&quot;: sub_1BC9C</span><br><span class="line">&quot;k&quot;: sub_199CC</span><br><span class="line">&quot;l&quot;: sub_1996C</span><br><span class="line">&quot;m&quot;: sub_1991C</span><br><span class="line">&quot;bb&quot;: sub_17B48</span><br><span class="line">&quot;o&quot;: sub_18874</span><br><span class="line">&quot;p&quot;: sub_126B0</span><br><span class="line">&quot;q&quot;: sub_153C4</span><br><span class="line">&quot;mu&quot;: sub_154BC</span><br></pre></td></tr></table></figure><h2 id="加载原dex"><a href="#加载原dex" class="headerlink" title="加载原dex"></a>加载原dex</h2><p>0x2A030 处调用 sub_265E8 函数，在这里面完成 dex 的加载，同样是做了混淆</p><p><img src="06.jpg"></p><h3 id="解密dex内存数据"><a href="#解密dex内存数据" class="headerlink" title="解密dex内存数据"></a>解密dex内存数据</h3><ol><li><p>在 0x2721C 处调用 sub_49604 ，该函数内部通过反射类 <code>java/lang/Class</code> 获取 <code>dexCache</code> 对象，再反射获取 <code>java/lang/DexCache</code> 的 <code>dexFile</code> 对象，再调用 <code>GetIntField</code> 将其转成在 native 层中的指针，在 android 6 上，该指针加 4 字节处指向当前壳 dex 在内存中的位置，最后通过匹配特征找到 dex 中的 injected_data 。<br><br><img src="12.jpg"></p></li><li><p>在 0x27366 处调了一个函数，观察第二个参数指向 injected_data 的某个位置，当函数跑完后该位置加密数据变成 dex ，说明调用解密函数解密 dex ，这里可以 dump 出 dex 。<br><br><img src="13.jpg"><br><img src="14.jpg"></p></li><li><p>来到 0x26E6A ，调用 access 函数查看 <strong>v1filter.jar</strong> 是否存在于 .cache 目录，若不存在则在 0x26D26 处解密并释放 v1filter.jar 到 .cache ，解密数据来自于 apk 包 <strong>assets</strong> 目录下的 <strong>resthird.data</strong></p></li></ol><h3 id="加载dex"><a href="#加载dex" class="headerlink" title="加载dex"></a>加载dex</h3><ol><li><p>0x273C6 处调用 sub_3FA6D ，这个函数在 0x44A52 处 hook 了 <code>art::DexFileVerifier::verify</code> 函数，hook 后 verify 函数开头指令如下图所示：<br><img src="09.jpg"><br>可以看到明显的 hook 特征，使用 LDR 指令跳转到函数 sub_AEF31EBC ，开头的 BX 指令的意义可能是为了保证 ldr 指令是 4 字节，这样可以固定使用 <code>LDR PC,[PC - 4]</code> 指令来取地址，不知道是否正确。<br>sub_AEF31EBC 给 R0 赋值为 1 就返回了，也就是恒定返回 true<br><img src="10.jpg"><br>回到 sub_3FA6D ，在 0x426BA 处 hook <code>art::ClassLinker::OpenDexFilesFromOat</code> ，hook 原理一样，fake 函数是 sub_433E8 ，这个函数留到下面再讲。<br>sub_3FA6D 最后调用 dlsym 获取 <code>art::DexFile::OpenMemory</code> 地址然后作为返回值返回，后面要用到这个函数加载 dex</p></li><li><p>0x26756 处调用 sub_1A7C4 ，这个函数的逻辑是对每一个 classes.dex ，在 .cache 下创建文件，写 4 字节的 dex magic 到文件中，这个 app 一共 10 个 dex 。<br><img src="08.jpg"><br>然后在 0x1AE44 处调用 <code>com/secneo/apkwrapper/H</code> 的 native 方法 <code>f</code> ，经过分析，该方法调用 <code>makeDexElements</code> 加载 dex 并且替换原 <code>classloader</code> 的 <code>dexPathList</code> 中的 <code>dexElements</code> 。<br>调用 makeDexElements 所传入的 dex 路径是就是 10 个 dex 所在的 .cache 目录，而 dex 只有 4 字节，直接加载肯定是失败的，那么前面 hook <code>OpenDexFilesFromOat</code> 的 fake 函数 <strong>sub_433E8</strong> 在这里起到作用，其逻辑如下：</p></li><li><p>在 0x4345A 判断加载的是否是 v1Filter.jar ，若是就在 0x435EE 处调用原 <code>OpenDexFilesFromOat</code> 做文件加载，v1Filter.jar 里面就是个工具类 dex<br>  <img src="11.jpg"></p></li><li><p>在 0x4350C 处判断是否加载 classes.dex ，若是就在 0x4352E 处找到相应的 dex 数据，然后在 0x43568 处调用 <code>OpenMemory</code> 完成内存加载</p></li></ol><p>接下来，在 OpenMemory 处下断点即可 dump 出所有 dex ，为了方便分析，可以使用这个工具把 dex 合并为 apk ：<a href="https://github.com/Simp1er/AndroidSec/blob/master/dex2apk.py">dex2apk</a></p><p>此外，分析过程中没有发现对 dex 做指令还原，后来我又确认了一下，在 dex 加载过后查看 DefineClass 、LoadMethod 和 LinkMethod 等函数开头有没有 hook 指令特征，然而一直到 jni_onload 跑完都没看到变化。去年分析的免费版也不是抽取壳，也是在 OpenMemory 处 dump 出 dex 。</p><h2 id="框架检测和反调试"><a href="#框架检测和反调试" class="headerlink" title="框架检测和反调试"></a>框架检测和反调试</h2><h3 id="magisk检测"><a href="#magisk检测" class="headerlink" title="magisk检测"></a>magisk检测</h3><p>0x2AB2C 处查看当前进程名是否是 <code>:bbs:com.secneo.apkwrapper.r.S</code> ，这个可能是检测 magisk 的 android 服务，不过我没在手机上找到这个服务，不知道具体如何检测。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">is_magisk_check_process</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  getpid(a1);</span><br><span class="line">  sub_15270((<span class="type">int</span>)v6);   <span class="comment">// 获取进程名</span></span><br><span class="line">  ......</span><br><span class="line">  decrypt_str((<span class="type">int</span>)v5, <span class="number">30</span>, <span class="number">201</span>);  <span class="comment">// 解密&quot;:bbs:com.secneo.apkwrapper.r.S&quot;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> ( !strncmp_0(v6, v5, v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 JNI_Onload ，0x2A142 处的 <code>BLX R5</code> 指令跳转到 sub_5f5c8 ，这个函数是实现反调试以及 frida 检测逻辑的地方。<br></p><h3 id="frida检测"><a href="#frida检测" class="headerlink" title="frida检测"></a>frida检测</h3><p>在 0x5fd12 处调用 sub_5A088 做 frida 检测</p><ul><li>从 <code>/proc/self/task/&lt;tid&gt;/status</code> 的 name 字段读出的字符串是不是 <code>&quot;gum-js-loop&quot;</code></li><li>从 <code>/proc/self/task/&lt;tid&gt;/status</code> 中读出的字符串是不是 <code>&quot;gmain&quot;</code></li><li>调用 <code>readlink</code> 读取 <code>/proc/self/fd/&lt;fd-id&gt;</code> ，匹配 readlink 读出的内容是不是 <code>&quot;linjector&quot;</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_5A088</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v1 = opendir_1(&amp;v29);   <span class="comment">// &quot;/proc/self/task&quot;</span></span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = readdir_0(v1);</span><br><span class="line">      v6 = open_1(&amp;v73, <span class="number">0x80000</span>);     <span class="comment">// &quot;/proc/self/task/&lt;tid&gt;/status&quot;</span></span><br><span class="line">      <span class="keyword">if</span> ( v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="keyword">if</span> ( is_str_match((<span class="type">const</span> <span class="type">char</span> *)&amp;v75, &amp;v17) )   <span class="comment">// &quot;gum-js-loop&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">          v2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( is_str_match((<span class="type">const</span> <span class="type">char</span> *)&amp;v75, (<span class="type">const</span> <span class="type">char</span> *)v16) )   <span class="comment">// &quot;gmain&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">          v2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close_1(v6);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v8 = opendir_1(&amp;v29);     <span class="comment">// &quot;/proc/self/fd&quot;</span></span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = readdir_0(v8);</span><br><span class="line">      <span class="keyword">if</span> ( !v9 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      readlink_1(&amp;v75, &amp;v73, <span class="number">256</span>);    <span class="comment">// &quot;/proc/self/fd/&lt;fd-id&gt;&quot;</span></span><br><span class="line">      decrypt_str_7((<span class="type">int</span>)&amp;v17, <span class="number">9</span>, <span class="number">205</span>);</span><br><span class="line">      <span class="keyword">if</span> ( is_str_match((<span class="type">const</span> <span class="type">char</span> *)&amp;v73, &amp;v17) )     <span class="comment">// &quot;匹配readlink读出的内容是不是&quot;linjector&quot;&quot;</span></span><br><span class="line">        v7 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>在 0x5fd00 和 0x5fd06 处调用 <code>pipe</code> 函数，创建两个管道用于父子进程通信<br>0x5f8ee 处 <code>fork</code> 进程，父进程逻辑如下：</p><ul><li>0x5fb50 处 hook <code>ptrace</code> ，hook 后的 fake 函数是 sub_5B044 ，该函数通过 svc 调用 <code>kill</code> 掉进程</li><li>0x5fb5c 处开线程，线程函数 sub_59970 调用 <code>inotify_add_watch</code> 函数监控文件 <code>/proc/self/mem</code></li><li>0x5fb56 处开线程，线程函数 sub_60ce0 调用 <code>fopen</code> 打开 <code>/proc/self/status</code> ，<code>fgets</code> 读取文件内容找到 “State:” ，然后读取值，再调用 <code>strcasestr</code> 匹配子字符串 <code>&quot;T (stopped)&quot;</code> 、<code>&quot;(zombie)&quot;</code> 以及 <code>&quot;t (tracing stop)&quot;</code> ，匹配到了程序会退出。接着打开 <code>/proc/self/task/&lt;tid&gt;/status</code> ，同样是读取 “State:” 的值以及匹配那几个子字符串。如果都没有匹配到就调用 sleep 睡眠然后重复上面的内容。同时我发现如果是单步过去的话 “State:” 的值会是 “sleeping” ，反调试就检测不到，而 F9 过去就会被检测到</li><li>最后往可写 pipe 写入 0xFF ，再从可读 pipe 读取一字节，这个字节如果不是 0xFF ，就做 svc 调用 kill 掉自己</li></ul><p>除了不 hook ptrace，子进程逻辑跟父进程一样，而且它也会用管道跟父进程通信，在读出的字节不是 0xFF 会 kill 掉自身。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>JNI_Onload 跑完后，回 java 层看到 <code>com/secneo/apkwrapper/AW</code> 的 <code>attachBaseContext</code> 调用 <code>com/secneo/apkwrapper/H</code> 类的 <code>attach</code> 方法，前面说过这个方法被 RegisterNatives 注册到 sub_2775C ，到这里一般是做资源替换和 application 替换，就不详细分析了。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>感觉现在大多数壳都是用 <code>makeDexElements</code> 加载磁盘上 dex 然后在 java 层做 <code>dexElements</code> 合并，磁盘上的 dex 不是掏空就是加密，然后在加载 dex 的调用链上找个函数 hook 完成解密，比如 <code>OpenCommon</code> ，恢复抽取的方法指令就 hook <code>loadMethod</code> 。<br>对于这个壳的反 frida ，亲测使用 hluda 的 spawn 模式可以过掉。然后因为有 ptrace 反调试，用 frida 或者调试器 attach 上去会崩，其它反调试可以编译修改内核绕过。<br>bb 壳除了上面分析的加固技术，还有防篡改技术，需要看看这篇文章：<a href="https://bbs.kanxue.com/thread-223141.htm">[原创]梆梆企业版加固技术之防篡改剖析</a></p>]]></content>
      
      
      <categories>
          
          <category> Android加固分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OLLVM混淆 </tag>
            
            <tag> anti-debug </tag>
            
            <tag> anti-frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小密盾so壳分析</title>
      <link href="/2022/10/24/%E5%B0%8F%E5%AF%86%E7%9B%BEso%E5%A3%B3%E5%88%86%E6%9E%90/"/>
      <url>/2022/10/24/%E5%B0%8F%E5%AF%86%E7%9B%BEso%E5%A3%B3%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>前段时间在网上看到一款 so 壳分析<a href="https://bbs.kanxue.com/thread-226926.htm">文章</a>，提供免费加固服务，直接拿文章的例子到官网加固下来练手。</p><span id="more"></span><h1 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h1><hr><p>设备：Nexus5<br>系统：Android 6<br>架构：armeabi-v7a</p><h1 id="加固前so逻辑"><a href="#加固前so逻辑" class="headerlink" title="加固前so逻辑"></a>加固前so逻辑</h1><hr><p>注册 Stringfromjni<br><img src="10.png"></p><h1 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h1><hr><p>ctrl+s 查看并进入 .init_array ，就三个 init 函数</p><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.init_array:000576D8                               AREA .init_array, DATA</span><br><span class="line">.init_array:000576D8                               ; ORG 0x576D8</span><br><span class="line">.init_array:000576D8 C8 68 00 00                   DCD sub_68C8                     ; 解密</span><br><span class="line">.init_array:000576DC D8 68 00 00                   DCD sub_68D8                     ; 析构初始化</span><br><span class="line">.init_array:000576E0 4C 69 00 00                   DCD sub_694C                     ; 保存函数指针到全局变量</span><br></pre></td></tr></table></figure><p><code>sub_68C8</code> 调用 mprotect 和 cacheflush ，八成是解密某个段的内容，sub_B6F4 负责改写<br><img src="04.jpg"></p><p>同时可以看到 JNI_Onload 函数是加密了的，而 sub_68C8 执行后 JNI_Onload 解密完成。</p><p><img src="05.jpg"></p><p>接下来断点 mprotect 拿到地址和大小 dump 下来，再 patch 回去，就能看到解密后的 JNI_Onload</p><p><img src="06.jpg"></p><h1 id="JNI-Onload函数"><a href="#JNI-Onload函数" class="headerlink" title="JNI_Onload函数"></a>JNI_Onload函数</h1><hr><p>JNI_Onload 可以 F5 查看伪代码，<code>sub_773C</code> 获取 android 系统环境信息，不管它，这里主要关注 <code>__cxa_cleanup_vir</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  JavaVM v2; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> env; <span class="comment">// [sp+Ch] [bp-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2 = *vm;</span><br><span class="line">  env = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v2-&gt;GetEnv(vm, (<span class="type">void</span> **)&amp;env, <span class="number">65540</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    prctl(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sub_773C(env);                              <span class="comment">// 获取android系统环境信息上传日志服务器</span></span><br><span class="line">    __cxa_cleanup_vir(dword_58898);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现反编译有问题，在 __cxa_cleanup_vir 下还有一个调用</p><p><img src="07.png"></p><p>看看 BLX R3 调用到哪里，如下图是在 bss 段的函数，说明该函数是运行时拷贝上去的</p><p><img src="08.png"></p><p>继续往下走看到它调用 FindClass 和 RegisterNatives ，并且注册的是 Stringfromjni ，那么这个函数就是实现未加壳前的 jni_onload 的逻辑</p><p><img src="09.png"> </p><p><code>__cxa_cleanup_vir</code> 函数就是负责生成 .bss 上的这段代码</p><h1 id="cxa-cleanup-vir函数"><a href="#cxa-cleanup-vir函数" class="headerlink" title="__cxa_cleanup_vir函数"></a>__cxa_cleanup_vir函数</h1><hr><p>函数做了混淆，而且不是平坦化和虚假控制流，如下图函数内有两个跳转，sub_4F820 和 turnin ，这两个函数内也是做了绝对跳转，手动跟有点费时间</p><p><img src="11.png"> </p><p>试一下 ida 自带的 trace ，在 Debugger -&gt; Tracing -&gt; Instruction tracing 打开指令跟踪，然后在调用 __cxa_cleanup_vir 的下一条指令处下断点，在这里让 trace 停止。</p><p>但是 trace 过程中遇到一个问题，ida 会错误识别指令为 thumb 指令，执行抛出 segment fault 导致 trace 停止，像下图这种</p><p><img src="12.png"> </p><p>手动 alt+G 修改有点麻烦，用 idapython 对给定范围内的代码设置执行模式</p><p><img src="13.png"> </p><p>接着跟到 turnin 有一条强制跳转指令 <code>mov PC, R0</code></p><p><img src="14.png"> </p><p>跳过去发现没有混淆，经过分析是加载原 so 以及调用原 so 的 init 函数</p><p><img src="15.png"></p><p>先来看 sub_CCC4 第一部分内容</p><p><img src="16.png"></p><p>sub_D3EC 调用 sub_D1F0 ，下图是其在循环中的代码，mprotect 和 memcpy 很惹眼，调试得知是对原 load 段内容做解密，然后拷贝到 bss 上</p><p><img src="17.png"></p><p>回到sub_CCC4，看第二部分内容</p><p><img src="18.png"></p><p>Sub_C63C 解密个别区段的内容，并且返回这些区段的地址，保存到 soinfo</p><p><img src="19.png"></p><p>起初不知道这里返回的地址上的内容是什么意思，直到发现其中一个地址上的内容是一堆字符串，对比加固前 so 的字符串表发现一摸一样，大胆猜测是 strtab ，用同样的办法一步一步把这些解密地址所代表的意义给推断出来（要是没原so就寄了）</p><p><img src="20.png"></p><p>最后是加载依赖库</p><p><img src="21.png"></p><p>回到 sub_CCC4 ，第三部分是符号重定位，依赖于两张表 .rel.dyn 和 .rel.plt</p><p><img src="22.png"></p><p>到这里，原 so 就加载到内存中，并且完成了依赖库加载、符号重定位、init 函数调用以及 JNI_Onload 的调用</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不像大多数的 so 内存动态解密壳，这种自加载so壳分析起来更麻烦，而且小密盾的 so 壳没法整体 dump ，它在内存中是不连续的。通过分析感觉自己对 so 加载流程不熟，有机会自己实现 so 自加载。<br>此外，ida 的 trace 功能不尽人意，一是有些参数信息比如字符串没打印出来，二是识别 thumb&#x2F;arm 模式的问题，当然这在 64 位下不存在，最后一个问题是会跟入函数，有时候我只想跟踪当前函数，对其它函数单步步过，它并不能满足这个需求，后续可能需要使用 idapython 自己实现 trace 。</p>]]></content>
      
      
      <categories>
          
          <category> Android加固分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> so壳 </tag>
            
            <tag> 混淆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
